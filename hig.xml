<?xml version='1.0' standalone='no'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book id="index" status="draft">
<bookinfo>
    <author><firstname>The GNOME Usability Project</firstname></author>
<copyright>
<year>2001</year>
<holder>Calum Benson, Adam Elman, Gregory Merchan, Seth Nickell, colin z robertson</holder>
</copyright>

<legalnotice>
  <para>
      Permission is granted to copy, distribute and/or modify this
      document under the terms of the <citetitle>GNU Free Documentation
      License</citetitle>, Version 1.1 or any later version published
      by the Free Software Foundation with no Invariant Sections, no
      Front-Cover Texts, and no Back-Cover Texts. You may obtain a copy
      of the <citetitle>GNU Free Documentation License</citetitle> from
      the Free Software Foundation by visiting <ulink type="http"
      url="http://www.fsf.org">their Web site</ulink> or by writing to:
      Free Software Foundation, Inc., 59 Temple Place - Suite 330,
      Boston, MA 02111-1307, USA.
  </para>
  <para>
      Many of the names used by companies to distinguish their products and
      services are claimed as trademarks. Where those names appear in any
      GNOME documentation, and those trademarks are made aware to the members
      of the GNOME Documentation Project, the names have been printed in caps
      or initial caps.
  </para>
</legalnotice>

<title>GNOME 2.0 Human Interface Guidelines (CVS draft)</title>

</bookinfo>

  <chapter id="intro">
    <title>Introduction</title>
    <para>
      This document tells you how to create applications that look right,
      behave properly, and fit into the Gnome user interface as a whole. It
      is written for interface designers, graphic artists and software
      developers who will be creating software for the Gnome environment.
      Both specific advice on making effective use of interface elements,
      and the philosophy and general design principles behind the Gnome
      interface are covered.
    </para>
    <para>
      These guidelines are meant to help you write applications that	are
      easy to use and consistent with the Gnome desktop. Following thse
      guidelines will have many benefits:
      <itemizedlist>
	<listitem><para>Because interface elements will look and
	behave the way they are used to, users can learn to use your
	program faster.</para></listitem>
	<listitem><para>Users (even advanced users) will be able
	accomplish tasks quickly and easily because the interface
	won't cause confusion or making things
	harder.</para></listitem>
	<listitem><para>Your application will have an attractive look
	that fits in with the rest of the desktop.</para></listitem>
	<listitem><para>When users change desktop themes, fonts and
	colors, your application will continue to look
	right.</para></listitem>
	<listitem><para>Your application will be accessible to all
	users, including those with disabilities or special
	needs.</para></listitem>
      </itemizedlist>
    </para>
    <para>
      To help you achieve these goals, these guidelines will cover basic
      interface elements, how to use them and put them together effectively,
      and how to make your application integrate well with the desktop.
    </para>
    <para>
      The recommendations here build on design aspects that have
      worked well in other systems, including Mac OS, Windows, Java
      and KDE. At the same time they retain a uniquely GNOME flavor.
    </para>

  </chapter>

  <chapter id="usabilityprinciples">
    
    <title>Usability Principles</title>

    <para>This section seeks to explain some of the basic principles which underlie the more specific technical guidelines recommended in this document.  We believe that these principles are important for all application development.</para>

    <sect1>
      <title>Design for People</title>

      <para>Remember that the purpose of any software application is to enable some group of people to accomplish a specific set of tasks.  The first thing you should do when designing your application is to establish who your users are, and what you want to enable them to do.</para>

      <para>For example, you may be designing an application which will enable engineers (software, electrical, or mechanical) to create diagrams.  You may be designing an application which will enable system administrators to configure and monitor a web server.  You may be designing an application which will help elementary school students to learn math.</para>

      <para>The important thing is that you know your audience, and you understand their tasks.  There are a large number of professional interaction designers who write books and teach courses on design methods which can help with this process (many of which are extremely useful).  Most of these methods, however, boil down to specific ways of understanding your users, understanding the tasks you want to help them accomplish, and finding ways to support those tasks in your application.</para>

    </sect1>
    <sect1>
      <title>Don't Limit Your User Base</title>

      <para>If you are designing an application for use by engineers, or by children, or by system administrators, you should make sure to create an application which can be used by <emphasis>all</emphasis> engineers, children, or system administrators, including those with disabilities or those who are native speakers of a language different from yours.  You should be aware of issues of accessibility and issues of internationalization and localization.</para>

      <sect2>
	<title>Accessibility</title>

	<para>Accessibility means enabling people with disabilities of some kind to participate in life's activities: in this case, specifically to use your software.  Your software should be usable with voice interfaces, screen readers, alternate input devices, and other assistive technologies.  Your software should also be usable by color-blind users (by not using color only to display critical information), by deaf users (by not using sound only to indicate critical information), and by users with limited movement (by enabling keyboard equivalents for commands).</para>

	<para>More information on accessibility in GNOME 2.0 can be found at the <ulink url="http://developer.gnome.org/projects/gap/">GNOME Accessibility Project</ulink>.</para>

      </sect2>
      <sect2>
	<title>Internationalization and Localization</title>

	<para>Internationalization is designing software so that it can function in different language environments.  Localization is the process of actually translating the messages, labels, and other interface elements of an application into another language.</para>

	<para>GNOME has excellent support for both internationalization (also referred to as i18n) and localization (also referred to as L10n).  In most cases, simply using standard GNOME APIs for displaying text and messages will allow you or others to localize your application for other locales.  For more information on how to make your application localizable, see the <ulink url="http://www.pango.org">Pango project home page</ulink> (Pango is the GNOME 2.0 API for rendering internationalized text), the <ulink url="http://www.gnome.org/i18n/">GNOME Translations page</ulink>, and the <ulink url="http://developer.gnome.org/projects/gtp/">GNOME Translation Project page</ulink>.</para>
      </sect2>
    
    </sect1>

    <sect1>
      <title>Create a Match Between Your Application and the Real World</title>

      <para>Your application should always use the user's language, using words, phrases, and concepts which are familiar to the user rather than terms from the underlying system.  The terms you use should be related to the user's conception of the tasks your application supports: for instance, in medicine, the paper folder which contains all information about a specific patient is called a "chart."  Hence, a medical application might refer to a patient record which contains the same information as a paper chart as a "patient chart" rather than as a "patient database record."</para>

      <para>You can frequently take advantage of your users' knowledge of the real world by using metaphor: that is, using a familiar concept from the outside world to represent elements within your application.  For example, an image of a file folder suggests a container into which documents can be placed; a recycling bin suggests a container into which items can be placed when they are no longer needed.</para>

      <para>When using metaphors, however, it is important to neither take the metaphor too literally, nor to extend the metaphor beyond its reasonable use.  For example, the capacity of a file folder should not be limited to the capacity of a physical file folder (which presumably could contain only a few documents before becoming unwieldy).  On the other hand, a trash can should not be used for anything other than holding discarded files; it should not be used, for example, to eject a removable disk such as a floppy or CD.</para>
    </sect1>

    <sect1>
      <title>Make Your Application Consistent</title>

      <para>Your application should be consistent with itself and with other applications in both its appearance and its behavior. This is one of the most important design principles, and probably the most famous, but is also one of the most commonly abused.</para>

      <para>The purpose of consistency is to enable users to apply their existing knowledge of their computing environment and other applications to understanding a new application.  Consistency not only enables users to become familiar with new applications more quickly, but also helps create a sense of comfort and trust in the overall environment.  Most of the recommendations in the GNOME HI Guidelines are designed to help you create applications which are consistent with the GNOME environment and other GNOME applications.</para>

      <para>However, a misapplied, or incomplete, consistency is actually worse than inconsistency.  If your application includes an "Undo" menu item for consistency, but it is always disabled because your application does not actually support Undo, this will serve to reduce users' trust in the availability of Undo in other applications in the environment.  In this case, your application should either support Undo, or you should eliminate the Undo menu item.</para>
    </sect1>

    <sect1>
      <title>Let Users Know What's Going On</title>

      <para>Your application should always keep the user informed of what's actually going on through appropriate feedback presented at an appropriate time.  The user should never have to guess about the status of the system or of your application.  When the user performs an action, provide feedback to indicate that the system has received the input and is operating on it. Feedback can be visual, audio, or both. If the system will take a long time to process the request, provide as much feedback as possible about how lengthy the operation will be. Types of helpful feedback include but are not limited to: cursor changes, animated throbbers, progress indicators, audio feedback such as a beep, and error messages. Error messages should use simple language, clearly state the problem, and provide solutions or tell the user how to get out of the current situation if possible.</para>

      <para>It is critically important that feedback be <emphasis>accurate</emphasis> and <emphasis>precise</emphasis>.  If you display a determinate progress indicator to display the state of completion of a task and it is inaccurate, the user will lose faith in progress indicators, and they will find the environment less usable.  If you display a generic error message which indicates that there is a problem but fails to provide enough information to diagnose or solve the problem, the user will be unable to continue his or her task.</para>
    </sect1>

    <sect1>
      <title>Keep It Simple and Pretty</title>

      <para>Your application should enable the user to concentrate on the task at hand.  In this vein, you should design your application to show only useful and relevant information and interface elements.  Every extra piece of information or extra interface element competes with the truly relevant bits of information and distracts the user from important information.  Hence, don't clutter your interface, and don't overload the user with buttons, menu options, icons, or irrelevant information.  Instead, use progressive disclosure and other techniques to limit what the user sees at any given moment.</para>

      <para>Finally, it is also important to present your information and interface elements in an aesthetically pleasing manner; a disorganized, cluttered-looking interface with a few elements can be just as distracting as an organized interface with too much information.  Make sure that dialog elements are cleanly aligned, and do not overuse or misuse color or graphics.</para>
    </sect1>

    <sect1>
      <title>Let the User Be in Control</title>

      <para>Remember that computers exist to serve humans.  A user should always feel in control, able to do what they want when they want.  This means that modes should generally be avoided; users should be able to switch between different tasks (and specifically, different windows) at any time.</para>

      <para>The user should also be able to set aspects of their environment to fit personal preferences.  It is very important, however, to avoid the trap of allowing too much configuration, or allowing the configuration of parameters which most users will not understand or find useful to modify.  Wherever possible, visual and behavioral parameters should be inherited from global preferences and settings such as the current GTK+ theme.</para>
    </sect1>

    <sect1>
      <title>Forgive the User</title>

      <para>We all make mistakes.  Whether we're exploring and learning how to use the system, or we're experts who just hit the wrong key, we are only human.  Whenever possible, the user should be able to quickly undo the results of his or her actions.</para>

      <para>In some cases when the action might be very dangerous, and there is no way to undo the result, the interface should warn the user and force a confirmation.  However, this type of confirmation should be avoided except in extreme cases; if faced with such confirmation messages frequently, users tend to simply ignore them, making them worse than useless.</para>

      <para>In all cases, the user's work should be sacrosanct; nothing your application does should lose or destroy user's work without explicit user action.  Among other techniques, this can be achieved by auto-saving backups of documents, and allowing multiple levels of undo.</para>

    </sect1>

    <sect1>
      <title>Enable Direct Manipulation</title>

      <para>Wherever possible, you should allow users to act on objects and data directly, rather than through dialog boxes or explicit commands.  For example, it is much more intuitive to drag a circle object around in a diagram rather than selecting a "Move" command from a menu while the circle is selected.</para>

    </sect1>

  </chapter>

<chapter id="desktop-integration">
    <title>Desktop Integration</title>
    
    <para>There are two elements to basic integration with the user environment of the GNOME Desktop. First, applications should place an entry in the panel menu. This is the mechanism by which users discover your application in order to execute it. Secondly, your application should add itself to the application registry, and if it supports any documents add those to the document type (MIME) registry. This allows the desktop and other applications to automatically launch your application when they encounter a document it can display or edit. This is an important first step in evolving a document centered interface.</para>
    <sect1 id="menuentries">
      <title>Placing Entries in the Panel Menu</title>
      
      <para>Applications should place entries in the GNOME panel menu. The panel menu provides a convenient way for users to survey the available applications and select one to perform their next task. </para>
      <para>The panel menu is arranged into a set of broad categories. An application should place an entry in just one of these categories, unless it is a an application-suite such as Evolution or OpenOffice, in which case it should place an entry for each sub-application in the appropriate category(s). Creation of new categories should be done cautiously to avoid a potentially overwhelming proliferation of menu items, and should be discussed with the community first. Just remember that users would probably rather have a simple menu system than to have your one application in a precisely defined category. The temptation to over-estimate the importance of your application to users can easily lead to the justification of a new category, so be careful to prioritize user preferences over productisation.</para>
      <para>Menu categories are:
	<itemizedlist>
	  <listitem><para>Internet</para></listitem>
	  <listitem><para>Multimedia</para></listitem>
	  <listitem><para>Office</para></listitem>
	  <listitem><para>Graphics</para></listitem>
	  <listitem><para>Utilities</para></listitem>
	  <listitem><para>Development Tools</para></listitem>
	  <listitem><para>Games</para></listitem>
	  <listitem><para>System</para></listitem>
	</itemizedlist>
        <note><para><emphasis>WHAT OTHER CATEGORIES SHOULD WE HAVE BY DEFAULT? THESE ARE ONLY THE ONES FOR GNOME-CORE....</emphasis></para></note>
      </para>
      <sect2 id="menu-entry-captions">
        <title>Menu Entry Captions</title>
	<para>Menu entries require captions (or "names" as the panel calls them) to textually describe the application. If an application falls into a general class of applications (for example, "Email Client" or "Word Processor") they should follow the format <emphasis>APPLICATION TYPE (APPLICATION NAME)</emphasis>. Rather than focusing on branding the menu system tries to encourage listing based on functionality. Users are more likely to be able to discover your application when they need it if it is listed by functionality rather than by name. This is particularly important on systems where numerous applications are installed by default, so the user is less aware of the mapping between names and functionality. Try to think of what information users will have when they look for your application when choosing a general class, and try to copy similar applications if they have already chosen a general class.</para>
	<para>In user testing of MIT's Athena system, users had a difficult time finding the file manager because they had never heard the name Nautilus before, and hence did not register the word when they looked for an application to fufill the concept "file manager". Unless the name of the program is very obvious (for example, "Font Selector"), it is preferable to describe the application in the caption by functionality rather than by name. The application name is retained both because it is important to give specific instances recognition, and because it clarifies the situation where multiple applications are installed filling the same general purpose.</para>
	<note><para><emphasis>WE SHOULD PROBABLY INCLUDE AN APPENDIX (OR AT LEAST A LONG INLINE LIST) OF A BUNCH OF GENERAL CLASSES. EVERY GOOD NAME FOR A GENERAL CLASS WE THINK OF NOW IS A BAD NAME AVOIDED IN THE FUTURE</emphasis></para></note>
	<itemizedlist>
	  <listitem>
	    <example>
	      <title>A caption for Nautilus</title>
	      <para>File Manager (Nautilus)</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A caption for the GIMP</title>
	      <para>Image Editor (GIMP)</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A caption for GnomeMines</title>
	      <para>Minesweeper (GnomeMines)</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A caption for Evolution's mail component</title>
	      <para>Email (Evolution)</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A caption for Evolution's calendar component</title>
	      <para>Calendar (Evolution)</para>
	    </example>
	  </listitem>
	</itemizedlist>
	
	<para>If no appropriate general class exists, applications may reasonably follow the format <emphasis>APPLICATION NAME</emphasis>. It is important to apply common sense in choosing which format to use. While it is generally preferable to list a general class, do not try to force a class where the information is not useful to the user. For example, listing all the entries in the Games section as <emphasis>Game (GAME NAME)</emphasis> would be awkward and redundant since the category they are contained in is already labled Games.</para>
	<tip>
	  <para>If you can think of another application that could be viewed as a competitor to your application (if not in number of features or quality at least in general area of use), your application probably belongs to some general class and should use the first format.</para>
	</tip>
	
	<itemizedlist>
	  <listitem>
	    <example>
	      <title>A caption for AisleRiot</title>
	      <para>Aisle Riot</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A caption for Time Tracking Tool</title>
	      <para>Time Tracking Tool</para>
	    </example>
	  </listitem>
	</itemizedlist>
	<para>If possible, it is better to remove explicit mention of GNOME or X-Windows or other platform details from menu entry captions. The user probably already knows what platform they are using, and if they don't, application names aren't the right place to inform them. Menu captions exist to assist users in finding the correct application to accomplish their tasks and should not burden them with technical details. Other technical details should also be avoided when the user does not need to know them or can infer them from context. For example, when both a client and a server for something are listed in the menus, drop the word "Client" from the caption for the client. Try not to clutter titles with unnecessary information, but be sure to retain enough information that similar applications are distinct from eachother.</para>
	<itemizedlist>
	  <listitem>
	    <example>
	      <title>A caption for Same Gnome</title>
	      <para>Same Game</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A caption for GNOME VideoLAN Client</title>
	      <para>Movie Player (VideoLAN)</para>
	    </example>
	  </listitem>
	</itemizedlist>
      </sect2>
      <sect2 id="menu-entry-tooltips">
	<title>Menu Entry Tooltips</title>
	<para>Panel menu tooltips should be provided to give the user some information on the tasks they can perform with the application. Tooltips should not be overly verbose, but should go beyond the simple description given by the caption to help users decide if a given entry is really the application they want. Users often view tooltips when they suspect they have found the right tool for a job, but aren't entirely sure and want more confirmation before they begin the potentially slow operation of launching the program. Sometimes they are also used to quickly explore the potential functionality of a large set of applications. Because they describe the user actions to be performed with the tool, panel menu tooltips should usually be phrased in verb form. It is particularly important to have a good tooltip when a short functional description isn't found, or when the <emphasis>APPLICATION NAME</emphasis> form of caption is used (and hence little information is provided to the user about the application in the caption).</para>
	<itemizedlist>
	  <listitem>
	    <example>
	      <title>A tooltip for Character Map</title>
	      <para>Insert special characters into documents</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A tooltip for Memprof</title>
	      <para>Check your application for memory leaks</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A tooltip for Same Gnome</title>
	      <para>Arrange long chains of similarly colored balls and eliminate them</para>
	    </example>
	  </listitem>
	  <listitem>
	    <example>
	      <title>A tooltip for Gnome Batalla Naval Client</title>
	      <para>Find and sink enemy ships in this networked rendition of Battleship</para>
	    </example>
	  </listitem>
	</itemizedlist>
      </sect2>
    </sect1>
    
    <sect1 id="mimedatabase">
      <title>Providing a Connection between Documents &amp; Applications</title>
      
      <para>The Application &amp; MIME database provides a mapping between document types (as defined by their MIME type) and applications. This is the mechanism by which Nautilus, Evolution and other applications decide what to launch when they encounter a document of a type they cannot handle. Users can edit the association between types &amp; applications in the "File Types &amp; Applications" capplet in the Control Center. Upon installation applications should associate themselves with any types they can handle, registering those types as necessary if they are not already present on the system. Technical details on performing this operation or other operations on the MIME database described in this section should be consulted in the <ulink url="http://developer.gnome.org/doc/API/gnome-vfs"><citetitle>GnomeVFS API reference</citetitle></ulink>.</para>
      <para>The preferred list for a particular document type defines applications which are considered first class handlers for that data type. The decision whether to appear in the preferred list or not is left to the discretion of the application developer, but you should generally only list your application in the preferred list if you think a majority of users manipulating that document will want to see your application in the <guimenu>Open With...</guimenu> menu in Nautilus. For example, while a text editor such as GEdit may be capable of editing all files of type text/*, it probably should not add itself to the preferred list for files of type text/html. While it is <emphasis>capable</emphasis> of editing and viewing these files, users will generally not prefer GEdit for HTML files. On the other hand, GEdit should register itself as being capable of handling these files, so if some user wishes to frequently use it to edit HTML files it is easy for them to add GEdit to the preferred list.</para>
<para>The Application &amp; MIME database provides a mapping between document types (as defined by their MIME type) and applications. This is the mechanism by which Nautilus, Evolution and other applications decide what to launch when they encounter a document of a type they cannot handle. Users can edit the association between types &amp; applications in the "File Types &amp; Applications" capplet in the Control Center. Upon installation applications should associate themselves with any types they can handle, registering those types as necessary if they are not already present on the system. Technical details on performing this operation or other operations on the MIME database described in this section should be consulted in the <ulink url="http://developer.gnome.org/doc/API/gnome-vfs"><citetitle>GnomeVFS API reference</citetitle></ulink>.</para>
  </sect1>
</chapter>

<chapter id="windows">
    <title>Windows</title>
    <para>Windows are an essential part of many graphical user interfaces. This section applies to top-level windows as they are the only windows apparent to the user.</para>

    <sect1 id="window-names">
      <title>Names</title>
      <para>All top-level windows must have names. The name must have the proper name of the application and an identification of the window's purpose or content. Windows which ordinarily do not stand alone, such as menus, must have names when they do stand alone.</para>
    </sect1>

    <sect1 id="window-frames">
      <title>Frames</title>
      <para>Most top-level windows will have frames; exception may include shaped windows and torn-off windows. An application window should not attempt to provide its own frame, but should provide hints to the window manager for the desired frame type.</para>
    </sect1>

    <sect1 id="window-modality">
      <title>Modality</title>
      <para>A mode is a limitation of the actions a user may take. As such, modes should be avoided. When used, a mode should provide a clear means of escape, such as the <guibutton>Cancel</guibutton> button in some dialogs. Modality has two degrees: local and global.</para>
      <para>A local mode will prevent the user from interacting with some of the controls in an application and might be entered when an error or exception has occured which could prevent the user from completing his task.</para>
      <para>A global mode should not be used by applications. The session and window managers are excepted as these are global interface features. The toolkit also makes use of a global mode for operations such as popping up menus or drag and drop.</para>
    </sect1>

    <sect1 id="window-focus">
      <title>Focus</title>
      <para>There are the focus types from which the user may choose: click-to-focus, enter-to-focus (also known as sloppy focus), and cross-to-focus (also known as focus follows mouse). Applications must not attempt to override the user's choice, but should hint to the window manager their focus requirements. If one of your application windows may have special focus requirements then consult the Inter-Client Communication Conventions Manual (ICCCM), the wm-spec of the Free Desktop Group, and the toolkit API for the appropriate input model and how to hint to the window manager.</para>
    </sect1>

    <sect1 id="window-other">
      <title>General Communication with the Window Manager</title>
      <para>The toolkit API should provide all the functions needed for communicating with the window manager. The wm-spec of the Free Desktop Group and the ICCCM provide a thorough explanation of the toolkit functions.</para>
      <para>The Feedback section provides more information about when to use the available forms of window manager communication.</para>
    </sect1>
    
    <sect1 id="primary-windows">
      <title>Primary Windows</title>
      <para>FIXME - normal frames; may have menu bar, tool bar, and status bar.</para>
    </sect1>
      
    <sect1 id="utility-windows">
      <title>Utility Windows</title>
      <para>FIXME - normal frames; should not have a menu bar, a tool bar, or a status bar (status should be indicated otherwise); these are also known as palettes and toolboxes.</para>
    </sect1>


    <sect1 id="alert-windows">
      <title>Alerts</title>
      <para>An alert is a modal secondary window for . . .</para>
      <para>FIXME - reduced or no frame; one or two buttons: <guibutton>OK</guibutton> for informing alerts, and effectively <guibutton>Cancel</guibutton> and <guibutton>OK</guibutton> for confirmation. No other controls: especially not the "Do not show this again" checkbutton. Perhaps locally modal, rarely globally modal.</para>
      <sect2 id="informational-alert">
	<title>Informational Alerts</title>
	<para>An informational alert should only be used when the user must know the information presented before continuing. Non-essential, auxilliary information should be presented by other means such as a status bar message.</para>
	<para>The informational alert should present a selectable message and an <guibutton>OK</guibutton> button. The button will be placed in the bottom right corner of the alert. Pressing <keysym>Enter</keysym> or <keysym>Escape</keysym> will dismiss the informational alert.</para>
      </sect2>
      <sect2 id="confirmational-alert">
	<title>Confirmational Alert</title>
	<para>A confirmational alert should be presented when the user's command may irreversibly destroy user data or create a security risk.</para>
	<para>The confirmational alert will present . . . </para>
      </sect2>
      <sect2 id="button-order">
	<title>Alert Buttons</title>
	
	<para>Most alerts should have an affirmative button and a negative button. Alternate actions, such as cancelling the action that initiated the question or providing another solution, may also be provided. Dangerous or archane alerts should also consider having a <guibutton>Help</guibutton> which provides more information on the particular situation and explains the user's options.</para>
	<formalpara><title>Affirmative Button</title><para>The affirmative button should be placed in the lower right corner of the alert. The affirmative button accepts the action proposed by the alert.</para></formalpara>
	<formalpara><title>Negative Button</title><para>The negative button should be placed immediately to the left of the affirmative button. The negative button rejects the action proposed by the alert.</para></formalpara>
	<formalpara><title>Help Button</title><para>A <guibutton>[Help]</guibutton> may be used to clarify alerts presenting potentially destructive options. The <guibutton>[Help]</guibutton> button should be placed in the lower left corner of the alert beneath the icon. Clicking <guibutton>[Help]</guibutton> should launch a help window clarifying the situation and detailing the actions performed by the other buttons. Any unobvious side effects of the buttons should also be explained.</para></formalpara>
	<formalpara><title>Alternate Actions</title><para>Extra buttons may be used to provide alternates to the primary action proposed by the alert text. These buttons should be placed to the left of the negative button. An example of a common alternate action would be <guibutton>[Don't Quit]</guibutton> (<guibutton>[Cancel]</guibutton> in Windows and Macintosh parlance) in a save confirmation alert. This is an alternative to the primary suggested action <quote>Save</quote> or the negative <quote>Don't Save</quote>.</para></formalpara>
	
	<para>Buttons are best phrased in verb form, as users will be less liable to answer alert backwards, and will be able to select an action with less hesitation. For example <guibutton>[Save]</guibutton> and <guibutton>[Quit]</guibutton> are better button names than than <guibutton>[Yes]</guibutton> and <guibutton>[OK]</guibutton></para>
	
	<!-- actually this is a trashy alert, somebody should make a good one with good phrasing -seth -->
	<figure id="alert-buttons">
	  <title>A save confirmation alert</title>
	  
	  <mediaobject><imageobject>
	      <imagedata fileref="images/save_alert.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Save confirmation alert: "               [Don't Quit] [Don't Save] [Save] "</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </sect2>

    </sect1>
      
    <sect1 id="dialog-windows">
      <title>Dialogs</title>
      <para>FIXME - reduced frame; at least the equivalents of <guibutton>Cancel</guibutton> and <guibutton>OK</guibutton>, possibly <guibutton>Help</guibutton> (in the secondary section) and an <guibutton><replaceable>Alternative</replaceable></guibutton> (and we probably need code to provide space between <guibutton>Help</guibutton> and <guibutton>Cancel</guibutton> for it.)</para>
    </sect1>
    
    <sect1 id="assistant-windows">
      <title>Assistants</title>
      <para>FIXME - frame type?; <guibutton>OK</guibutton> is either <guibutton>Next</guibutton> or, on the last page, <guibutton>Finish</guibutton>. <guibutton>Cancel</guibutton> is <guibutton>Back</guibutton> (or <guibutton>Previous</guibutton>?); there should never be a <guibutton>Help</guibutton>, the assistant is the help; modality?; escape path?</para>
      <para>An assistant is an application modal <!-- modal? --> secondary window to guide the user through a set of operations which either must be performed sequentially, or are best presented as such.</para>
    </sect1>
    
</chapter>

<chapter id="menus">
    <title>Menus</title>

<!-- <sect1 id="menu-principles"> -->

<!-- TODO:
- Tear-off menus?
- Menu bar position
- Menu bar hiding
- When should there be a menu bar?
-->

<!-- <title>Menu Principles</title> -->

<para>Menus are the means by which the application commands and some options should be made available to the user.</para>

<sect1 id="menu-types">
<title>Types of Menus</title>

<sect2 id="menu-types-drop-down">
<title>Drop-Down Menus</title> <!-- "Pull-down" menus? -->
<para>The primary application window should possess a menubar providing a number of drop-down menus. This menubar will be visible at all times and will always be accessible via the keyboard as well as the mouse, and for this reason it should give access to all commands available in the application.</para>
</sect2>

<sect2 id="menu-principles-context">
<title>Popup menus</title>
<para>Clicking on an object with the right mouse button may display a popup menu which should contain commands which can be applied to the selected object. (The act of clicking may change the selection.) Popup menus are accessible via the keyboard shortcut <keycombo action="simul"><keycap>Shift</keycap><keycap>F10</keycap></keycombo>.
<!-- Since the user may not be aware of their presence, any items they contain should also be available via the application's menubar. -->
<!-- http://bugzilla.mozilla.org/show_bug.cgi?id=34357 -->
</para>
</sect2>

</sect1>

<sect1 id="menu-organisation">
<title>Menu Organisation</title>
<para>It should be easy for a user to find the command they need in the menu hierarchy. Menus should contain only items which are related to the title of the menu. Menus and menu items should not appear or disappear while the application is running.</para>

<sect2 id="menu-organisation-submenus">
<title>Submenus</title>
<para>Submenus may be used to add a further level of hierarchy to a menu and to save space in an interface. Submenus should be used sparingly, since they are physically difficult to navigate and they make it harder to find the items they contain.</para>
</sect2>

<sect2 id="menu-organisation-separators">
<title>Separators</title>
<para>Related items should be grouped together on a menu and should be separated from other groups using separators. This creates a set of visual landmarks and makes it easier for the user to quickly scan a menu for the item they are interested in.</para>
</sect2>

</sect1>

<sect1 id="menu-names">
<title>Naming Conventions</title>
<para>Most menu items will be labelled with verbs or adjectives, which describe commands or properties respectively. Menu items should have the first letter of the first word and of any significant words capitalized. See <link linkend="layout-capitalization">Capitalization</link> for more information.</para>
<para>Where a command requires further input from the user before it can be performed, it should be marked with an ellipsis ("..."). However, items should not be given an ellipsis to indicate only that a confirmation dialog will be presented or that the result of a command will be that a dialog is presented to the user.</para>
</sect1>

<sect1 id="menu-unavailable">
<title>Unavailable Commands</title>
<para>A menu item should be made insensitive when its command is unavailable. For example, the <menuchoice><guimenu>Edit</guimenu> <guimenuitem>Copy</guimenuitem></menuchoice> item, which issues the command to copy selected data to the clipboard, should not be activatable when there is no data selected.</para>
<para>Do not remove an item from the menu, the toolkit will handle changing its appearance according to input-sensitivity. The user should be able to see
commands which might be available at other times and keeps the item in a memorable place.</para>
</sect1>

<sect1 id="menu-toggled">
<title>Toggled Menu Items</title>
<para>Menu items may be toggled between two states. This may be done either independently in the same way as check boxes or as part of a group as with radio buttons.</para>
<para>Any group of items operating in the same manner as a group of radio buttons should appear on their own in a menu or submenu or be separated from other items in the menu by using separators.</para>
</sect1>

<sect1 id="menu-shortcuts-accesskeys">
<title>Shortcuts and Access Keys</title>
<!-- Eeek! Names! Names! The previous version contradicted the API. We still need a conclusion. -->
<para>As with other controls, all menu items should have an access key associated with them. Unlike other controls, once a menu is visible, its access keys are accessible just by typing the letter; it is not necessary to press the Alt key at the same time.</para>
<para>Developers may assign keyboard shortcuts to menu items. It is not necessary to assign shortcuts to every item -- just those which will be frequently used.</para>
<para>Shortcuts consist of the <keysym>Control</keysym> key and an alphanumeric key, or of one of the keys <keysym>F1</keysym>-<keysym>F12</keysym>, <keysym>Insert</keysym>, <keysym>Delete</keysym>, <keysym>Home</keysym>, <keysym>End</keysym>, <keysym>Page Up</keysym> or <keysym>Page Down</keysym>. The <keysym>Shift</keysym> key may be used as an additional modifier for commands which are related to or the opposite of the command accessed without the <keysym>Shift</keysym> key.  See <link linkend="shortcuts">Shortcut Keys</link> for more information.</para>
</sect1>

<sect1 id="standard-menus">
	
<title>Standard Menus</title>

<para>There are a number of standard drop-down menus for common operations. The menus on a menubar should be placed in the following order: <guimenu>File</guimenu>, <guimenu>Edit</guimenu>, <guimenu>View</guimenu>, <guimenu>Format</guimenu>, <replaceable>application-specific menus</replaceable>, <guimenu>Bookmarks</guimenu>, <guimenu>Go</guimenu>,<guimenu>Tools</guimenu>, <guimenu>Help</guimenu>. (Help should be the rightmost menu, but it should not be flush-right.)</para>

<sect2 id="menu-standard-file">

<title>File</title>

<para>
<!-- Note from GJM: I'm updating this to use markup rather than semi-literal symbols.
          The HTML version will be not show underlines until we get that fixed,
          but in the meanwhile we'll have nice printed versions.
          We might want to use graphics instead.
     Later note from GJM: DocBook sucks.
          There's no reasonable way to handle this without graphics.
          I'll be screenshooting, cropping, etc. then adding them in.
  -->
<literallayout class="monospaced"><guimenu><accel>F</accel>ile</guimenu>
<guimenuitem><accel>N</accel>ew                Ctrl-N</guimenuitem>
<guimenuitem><accel>O</accel>pen...            Ctrl-O</guimenuitem>
<guimenuitem>Open <accel>R</accel>ecent        ></guimenuitem>
<guimenuitem>---</guimenuitem>
<guimenuitem><accel>S</accel>ave               Ctrl-S</guimenuitem>
<guimenuitem>Save <accel>A</accel>s...</guimenuitem>
<guimenuitem>Re<accel>v</accel>ert to Saved</guimenuitem>
<guimenuitem><accel>C</accel>lose              Ctrl-W</guimenuitem>
<guimenuitem>---</guimenuitem>
<guimenuitem><accel>P</accel>rint              Ctrl-P</guimenuitem>
<guimenuitem>Print Preview...</guimenuitem>
<guimenuitem>Page Setup...</guimenuitem>
<guimenuitem>---</guimenuitem>
<guimenuitem>Close All                         Shift-Ctrl-W</guimenuitem>
<guimenuitem><accel>Q</accel>uit               Ctrl-Q</guimenuitem></literallayout>
</para>

<para>
All applications should have a <guimenu>File</guimenu> menu which should contain items relating to creating, opening, saving, closing and printing documents and for exiting the application.
</para>

<para>
Applications which do not obviously operate on files may rename this menu to something more appropriate. For example, games may have a <guimenu>Game</guimenu> menu instead of a <guimenu>File</guimenu> menu.
</para>

<sect3>

<title>File Access</title>

<para>
On document-editing applications, the items <guimenuitem><accel>N</accel>ew</guimenuitem>, <guimenuitem><accel>O</accel>pen</guimenuitem>, <guimenuitem><accel>S</accel>ave</guimenuitem>, <guimenuitem>Save <accel>A</accel>s</guimenuitem> and <guimenuitem><accel>C</accel>lose</guimenuitem> must be present, <guimenuitem>Revert</guimenuitem> should be present, and <guisubmenu>Open <accel>R</accel>ecent</guisubmenu> may be present.
</para>

<variablelist>

<varlistentry>
<term>New</term>
<listitem>
<para>
Creates a new document. The <guimenuitem><accel>N</accel>ew</guimenuitem> command should create a new window or tab (depending on the users MDI settings) with a blank document in it. <!-- FIXME: titling of new documents -->
</para>

<para>
Where the application may create a number of different types of document, the <guimenuitem><accel>N</accel>ew</guimenuitem> item may be a submenu containing entries for these various types. These entries should be labelled <guimenuitem>New <replaceable>document type</replaceable></guimenuitem> and the most commonly used item should be the first entry in the submenu and should be given the <keycombo><keycap>Ctrl</keycap><keycap>N</keycap></keycombo> shortcut.
</para>
<para>
A blank document will not necessarily be truly blank. For example, a document created from a template may already contain some data.<!-- FIXME: More on templates -->
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Open</term>
<listitem>
<para>
Opens an existing document. The user should be presented with a standard file open dialog from which they may choose an existing file. If the user's choice is already open in that application then the user should be notified via a dialog that the file is already open and the window containing that file should be given the focus and raised. If the current window contains a blank untitled document then it should be replaced with the selected file. Otherwise the file should be opened in a new window.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Open Recent</term>
<listitem>
<para>
Allows the user to open a recently used file. The application should maintain a history of recently opened documents and these should be accessible via a submenu. Selecting one of these files should open that file in the same way that <guimenuitem><accel>O</accel>pen</guimenuitem> does.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Save</term>
<listitem>
<para>
Saves the document to its current filename. If the document has a filename associated with it then the document should be saved to that file without any further interaction with the user. If there are any additional options involved in saving a file (eg. DOS or UNIX-style line endings in a text file) then these should remain as they were the last time the document was saved. If the document has no associated filename then the action should be the same as that of <guimenuitem>Save As</guimenuitem>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Save As</term>
<listitem>
<para>
Saves the document to a new filename. The <guimenuitem>Save <accel>A</accel>s</guimenuitem> command should present the user with a standard file save as dialog and save the file with the chosen file name. <!-- FIXME: errors, additional information-->
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Revert</term>
<listitem>
<para>
Reverts the document to the last saved state. The user should be presented with with a warning that all changes will be lost and given the option of cancelling before reloading the file.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Close</term>
<listitem>
<para>
Close the current document. If the document in the current window has unsaved changes then the user should be presented with a dialog giving the option to save changes (which should function like the <menuchoice><guimenu>File</guimenu> <guimenuitem>Save</guimenuitem></menuchoice> command), discard the changes or cancel the action. If the window being closed is the last open document of that application then the application should, in the case of an SDI interface, leave the user with a blank document, or, in the case of a controlled SDI interface, the control window should be left open.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>

<title>Printing</title>

<variablelist>

<varlistentry>
<term>Print</term>
<listitem>
<para>
Prints the current document. The <guimenuitem>Print</guimenuitem> command should brings up a print dialog allowing the user to set such options as the page range to be printed, the printer to be used, and so on. The dialog should contain a button marked <guibutton>Print</guibutton> which should start the actual printing and close the dialog.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Print Preview</term>
<listitem>
<para>
Shows the user what the printed document will look like. The <guimenuitem>Print Preview</guimenuitem> command should bring up a new window containing an accruate represenation of the appearance of the document as it would be printed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Page Setup</term>
<listitem>
<para>
Allows the user to control print-related settings. The user should be presented with a dialog allowing the user to set such options as portrait or landscape format, margins, and so on.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>

<title>Quitting</title>

<para>
All Applications must have a <guimenuitem>Quit</guimenuitem> item. Applications which are capable of editing multiple documents simultaneously should have a <guimenuitem>Close All</guimenuitem> item.
</para>

<variablelist>

<varlistentry>
<term>Quit</term>
<listitem>
<para>
Quit the application. If there are unsaved changes in any of the currently open documents then the user should be presented with a dialog listing those documents and giving the option to save all, discard all, or cancel. Save All should behave like the File|Save command applied to every unsaved document. If there are no unsaved changes then the application should quit with no further interaction with the user.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Close All</term>
<listitem>
<para>
Close all open documents. If there are unsaved changes in any of the currently open documents then the user should be presented with a dialog listing those documents and giving the option to save all, discard all, or cancel. Save All should behave like the <menuchoice><guimenu>File</guimenu> <guimenuitem>Save</guimenuitem></menuchoice> command applied to every unsaved document. For an SDI application, <guimenuitem>Close All</guimenuitem> should leave the user with a blank document, and with a controlled SDI application the user should be left with the controlling window.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect3>

</sect2>

<sect2 id="menu-standard-edit">

<title>Edit</title>

<para>
<literallayout class="monospaced"><guimenu><accel>E</accel>dit</guimenu>
<guimenuitem><accel>U</accel>ndo <replaceable>action</replaceable>        Ctrl-Z</guimenuitem>
<guimenuitem><accel>R</accel>edo <replaceable>action</replaceable>        Ctrl-Shift-Z</guimenuitem>
<guimenuitem>---</guimenuitem>
<guimenuitem>Cu<accel>t</accel>                Ctrl-X</guimenuitem>
<guimenuitem><accel>C</accel>opy               Ctrl-C</guimenuitem>
<guimenuitem><accel>P</accel>aste              Ctrl-V</guimenuitem>
<guimenuitem><accel>D</accel>elete             Del</guimenuitem>
<guimenuitem>Select <accel>A</accel>ll         Ctrl-A</guimenuitem>
<guimenuitem>---</guimenuitem>
<guimenuitem>Find               Ctrl-F</guimenuitem>
<guimenuitem>Replace            Ctrl-R</guimenuitem>
<guimenuitem>---</guimenuitem>
<guimenuitem>Preferences...</guimenuitem></literallayout>
</para>

<para>
The <guimenu>Edit</guimenu> menu should contain items relating to editing the document, clipboard handling, selection and searching and replacing.
</para>

<sect3>

<title>Modification History</title>

<para>
Document-editing applications are recommended to maintain a history of modifications to a document and the state of the document between each action. The Undo and Redo commands are used to move through this history. The <guimenuitem>Undo</guimenuitem> and <guimenuitem>Redo</guimenuitem> items on the menu should preferably include the name of the action they will undo or redo. They should always be separate menu items with separate keyboard shortcuts, even if the application is capable of only one undo level.
</para>

<variablelist>

<varlistentry>
<term>Undo <replaceable>action</replaceable></term>
<listitem>
<para>
Undoes the previous action in the history. The document should be changed to the state it was in before the previous action was performed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Redo <replaceable>action</replaceable></term>
<listitem>
<para>
Redoes the following action in the history. After the user has travelled back through the modification history with the <guimenuitem>Undo</guimenuitem> command, the <guimenuitem>Redo</guimenuitem> command should move the user forwards through that history and change the document state to the state it was in after that action had been performed.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>Manipulating Selected Data</title>

<variablelist>
<varlistentry><term>Cut</term>
<listitem><para>Removes the selected content and places it onto the clipboard. The content should be removed in the same manner as <guimenuitem><accel>D</accel>elete</guimenuitem>. This command should only be available when a section of the document is selected.</para></listitem>
</varlistentry>

<varlistentry><term>Copy</term>
<listitem><para>Copies the selected content onto the clipboard. This command should only be available when a section of the document is selected.</para></listitem>
</varlistentry>

<varlistentry><term>Paste</term>
<listitem><para>Inserts the contents of the clipboard at the caret or, if part of the document is selected, replaces that part with the clipboard contents.</para>
</listitem>
</varlistentry>

<varlistentry><term>Clear</term>
<listitem><para>Removes the selected content without placing it on the clipboard.</para></listitem>
</varlistentry>
<varlistentry><term>Select All</term>
<listitem><para>Selects all parts of the document.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>

<title>Searching and Replacing</title>

<variablelist>

<varlistentry><term>Find</term>
<listitem><para>Brings up a Find dialog.</para></listitem>
</varlistentry>

<varlistentry><term>Replace</term>
<listitem><para>Brings up a Replace dialog.</para></listitem>
</varlistentry>

</variablelist>

<!-- Note moved here by CB from the middle of his stuff... --> 
<note>
<title>For Discussion</title>
<para><guimenuitem>Find</guimenuitem> should be used for functions that locate text etc. in the currently loaded/focused document, with results highlighted in-place.</para>
<para><guimenuitem>Search</guimenuitem> should be used for functions that locate text etc. in locations (potentially) other than the current document, e.g. mail folders, website, disk partition etc., with results generally shown in a separate window.</para> 
</note>

</sect3>

<sect3>
<title>User Preferences</title>
<para>User preferences pertaining to the entire application (in all its instances) should be editable from a preferences dialog. <!-- or utility window? --></para>
</sect3>
</sect2>
      <sect2 id="menu-standard-view">
	<title>View</title>
	<para>FIXME</para>

	<para>
	  <literallayout class="monospaced"><guimenu><accel>V</accel>iew</guimenu>
	    <!-- FIXME -->
	  </literallayout>
	</para>
	
      </sect2>
      
      <sect2 id="menu-standard-format">
	<title>Format</title>
	<para>FIXME</para>
	
	<para>
	  <literallayout class="monospaced"><guimenu><accel>F</accel>ormat</guimenu>
	    <!-- FIXME -->
	  </literallayout>
	</para>
	
      </sect2>
      
      <sect2 id="menu-standard-tools">
	<title>Tools</title>
	<para>FIXME</para>
	<para>
	  <literallayout class="monospaced"><guimenu><accel>T</accel>ools</guimenu>
	    <!-- FIXME -->
	  </literallayout>
	</para>
      </sect2>

<sect2 id="menu-standard-help">

<title>Help</title>

<para>
<literallayout class="monospaced"><guimenu><accel>H</accel>elp</guimenu>
<guimenuitem><accel>S</accel>earch Help</guimenuitem>
<guimenuitem>Help <accel>C</accel>ontents      F1</guimenuitem>
<guimenuitem><accel>A</accel>bout <replaceable>appname</replaceable></guimenuitem></literallayout>
</para>

<variablelist>

<varlistentry>
<term>Search Help</term>
<listitem>
<para>
Brings up a dialog allowing the user to search the application's documentation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Help Contents</term>
<listitem>
<para>
Brings up the default gnome help browser with the contents page of the application's documentation.
</para>
</listitem>
</varlistentry>

<!-- What about context-sensitive help? How will that work? Do we want to give it the F1 shortcut? -->

<varlistentry>
<term>About <replaceable>appname</replaceable></term>
<listitem>
<para>
Brings up the About dialog for the application. The dialog should contain the name and version number of the application, a short description of what the application does, contact details of the authors, a copyright notice, and a pointer to the license under which the application is made available.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect2>

</sect1>

</chapter>
 
    <!-- Toolbars (subsection of menus+toolbars) -->
<!-- Realigning this section. Toolbars are top-level and Palettes (a.k.a. Toolboxes or Utility Windows) fall below. -->
<!--
<chapter id ="toolbars-palettes">
    <title>Toolbars and Palettes</title>
    
    <sect1 id="toolbars">
-->
<chapter id="toolbars">
      <title>Toolbars</title>
      
      <para>A toolbar is a strip of controls that allows convenient access to commonly-used functions. Most toolbars only contain graphical buttons, but in more complex applications, other types of controls such as dropdown lists, can also be useful.</para>

      <note><para>Although the latter is just a side-effect of the fact that palettes can't be created with the standard toolbar widgets-- it would be rather nice if they could, especially as they would then automatically feature in the toolbar keyboard navigation order.</para></note>
      
      <figure id="mail-toolbar-example">
	<title>Example toolbar from an email composition window</title>
	
	<mediaobject><imageobject>
	    <imagedata fileref="images/EvoToolbar.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Example email composition toolbar</phrase>
	  </textobject>
	</mediaobject>
      </figure>

      <figure id="web-toolbar-example">
	<title>Example toolbar from a web browser window</title>
      
	<mediaobject><imageobject>
	    <imagedata fileref="images/GaleonToolbar.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Example web browser toolbar</phrase>
	  </textobject>
	</mediaobject>
      </figure>
	
      <figure id="fileman-toolbar-example">
	<title>Example toolbar from a file manager window</title>

	<mediaobject><imageobject>
	    <imagedata fileref="images/GtkToolbar_browserdefault.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Example file manager toolbar</phrase>
	  </textobject>
	</mediaobject>
      </figure>

      <figure id="text-toolbar-example">
	<title>Example toolbar from a text editor window</title>

	<mediaobject><imageobject>
	    <imagedata fileref="images/GtkToolbar_gedit.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Example text editor toolbar</phrase>
	  </textobject>
	</mediaobject>

      </figure>
<!-- Notes from GJM:
      Text-on-the-side toolbars are now part of Gtk+.
      Stock items have mnemonics/access keys. I don't think they should.
  -->
      <note>
	<title>For discussion</title>
	<para>A few people only want to recommend one type of toolbar.  Which should it be?  We can't really recommend the GAL one because it's not part of core GNOME.  On the other hand, the Gtk one is somewhat clunky, and projects like Evo, AbiWord etc. are unlikely to switch to it anyime soon.</para>
      </note>
      
      <para>Careful and consistent toolbar design speeds up the user's task by giving direct access to functions that would otherwise be hidden on a menu.  Use them only for the most important functions, however.  Having too many toolbar controls reduces their efficiency by making them harder to find, and too many rows of toolbars reduces the amount of screen space available to the rest of the application.</para>

    <sect1>
	<title>Appearance and Content</title>

	<para>The effectiveness of toolbars is increased by maintaining a level of consistency between different applications.  The toolbar is one of the first parts of your application that a user will see the first time they run it, so by providing a toolbar that looks familiar to them, you can immediately make them feel comfortable about using your application.</para>

	<para>As well as following the recommendations and examples given in this section, look at the toolbars in other well-designed GNOME 2.0 applications for guidance when deciding what&mdash; and what not&mdash; to put on your application's toolbar.</para>
	
	<para>However many toolbars or palette windows your application provides, by default there should be one main toolbar that provides a subset of the application's overall functionality.  Many of the buttons on this toolbar will be the same regardless of the type of application.</para>

	<para>For example, the main toolbar in an office application should nearly always have <guilabel>New</guilabel>, <guilabel>Open</guilabel> and <guilabel>Save</guilabel> as its first three toolbar buttons.  Similarly, the first few buttons in a browser application should alway include <guilabel>Back</guilabel>, <guilabel>Forward</guilabel>, <guilabel>Stop</guilabel> and <guilabel>Reload</guilabel>, in that order.</para>

	<para>Recommendations:</para>

	<itemizedlist>

	  <listitem><para>Place only the most commonly-used application functions on your toolbars.  Don't just add buttons for every menu item.</para></listitem>

	  <listitem><para>Applications that require a single toolbar with a few buttons should use the standard GtkToolbar control.  Complex applications that require more buttons or multiple toolbars should consider using the Evolution/Abiword/Gnumeric style of "slim" toolbar.</para></listitem>
	  
	  <listitem><para>By default, have your toolbars appear directly below the main menu bar.</para></listitem>
	  
	  <listitem><para>Allow toolbars to be turned on and off in your application's <guilabel>Preferences</guilabel> dialog and by using the <menuchoice><guimenu>View</guimenu><guimenuitem>Toolbar</guimenuitem></menuchoice> menu item.  If there is more than one toolbar, they are turned on and off by individual entries in the <menuchoice><guimenu>View</guimenu><guimenuitem>Toolbar</guimenuitem></menuchoice> submenu.</para></listitem>
	  
	  
	  <listitem><para>All functions that appear on your toolbars must also accessible via the main menu bar, either directly (i.e. an equivalent menu item) or indirectly (e.g. in the <menuchoice><guimenu>Options</guimenu><guimenuitem>Settings</guimenuitem></menuchoice> dialog).</para></listitem>
	  
	  <listitem><para>Arrange toolbar buttons in the same order and groupings as their equivalents on the main menu bar. In particular, always group sets of mutually-exclusive toolbar buttons.</para></listitem>

	  <listitem><para>Don't add buttons for <guilabel>Help</guilabel> or <guilabel>Quit</guilabel> to your toolbar by default, as these are rarely used and the space can often better used for more useful controls.  Similarly, <guilabel>Undo</guilabel>, <guilabel>Redo</guilabel> and the standard clipboard functions should only be provided by default if there is space on the toolbar to do so without sacrificing more useful, application-specific controls.</para></listitem>
	  
	  <listitem><para>Provide options to show toolbar buttons as text, graphics or both&mdash; see the <link linkend="view-toolbar">proposed menu structure for controlling toolbar display</link>.  Also provide an option to return all toolbars in your application to the control center default for this setting.</para></listitem>
	  
	  <listitem><para>Allow users to configure toolbars to contain their own selection of commands, in whatever order they choose.  If you do this, you should also provide an option to return the toolbars to their default configuration.</para></listitem>
	  
	  <listitem><para>Save your application's toolbar position and contents in the application configuration file &lt;give GConf key?&gt;, and restore them when the application is restarted.</para></listitem>

	</itemizedlist>

</sect1>

<sect1>
	<title>Controlling Display and Appearance</title>

	<para>For each toolbar in your application, the user should be able to choose whether or not to show that toolbar, and whether to show its contents as icons only, text only or both.  (Ideally, default settings for icons/text/both should be set in the control center, but over-rideable in each individual application&mdash; is this the current plan for 2.0?  If not, default for each application should probably be Icons Only).</para>

	<para>Recommendations:</para>

	<itemizedlist>
	  
	  <listitem><para>Allow the user to override the control center toolbar defaults for your particular application in the application's <guilabel>Preferences...</guilabel> dialog.  In particular, ensure that the user can:</para>
	    
	    <itemizedlist>

	      <listitem><para>separately choose to show each toolbar in your application as icons only, text only, or both</para></listitem>

	      <listitem><para>return the icon/text/both status for all toolbars in your applicaton to the system default</para></listitem>

	      <listitem><para>return the layout and ordering of all toolbars in your application to the application default</para></listitem>
	    
	    </itemizedlist>
	    
	  </listitem>
	  
	  <listitem><para>If your application has a single toolbar, allow the user to turn it on or off by placing a <guimenuitem>Toolbar</guimenuitem> menu item on the application's <guimenu>View</guimenu> menu that can be checked or unchecked.</para></listitem>

	  <listitem><para>If your application has two or three toolbars, allow the user to turn them on or off individually by placing a menu item for each one on the application's <guimenu>View</guimenu> menu.  For example, <guimenuitem>Main Toolbar</guimenuitem>, <guimenuitem>Drawing Toolbar</guimenuitem>, <guimenuitem>Formatting Toolbar</guimenuitem>. Place the items together in a single group on the menu, with <guimenuitem>Main Toolbar</guimenuitem> first (if your application has one), followed by the others in alphabetical order.</para></listitem>

	  <listitem><para>If your application has more than three toolbars, allow the user to turn them on or off individually by placing a menu item for each one in a <guisubmenu>Toolbars</guisubmenu> sub-menu on the application's <guimenu>View</guimenu> menu.  Place the <guimenuitem>Main Toolbar</guimenuitem> item first (if your application has one), followed by the others in alphabetical order.</para>
	    
	    <figure id="view-toolbar">
	      <title>Example View menu fragments for applications with one toolbar (left), two or three toolbars (middle), or four or more toolbars (right)</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/view-toolbar.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>Example View menu for application with single toolbar</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	
	  </listitem>
	  
	</itemizedlist>
	
	<note>
	  <title>For Discussion</title>
	  <para>How should MDI and toolbars be handled?</para>
	</note>

</sect1>
<sect1>
	<title>Labels and Tooltips</title>
	
	<para>Many controls that appear on your toolbar will require a text label that appears below or beside it.  This should normally be a single word description of that control's function.</para>
	
	<para>Every control that appears on your toolbar should have a tooltip, whether or not that control has an associated text label.</para>
	
	<para>Recommendations:</para>

	<itemizedlist>

	  <listitem><para>If your toolbar is configured to show labels below button icons, show a label for every button.  For example:</para>

	    <figure>
	      <title>Toolbar with labels under all buttons</title>
	      
	      <mediaobject><imageobject>
		  <imagedata fileref="images/GtkToolbar_gedit.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>Toolbar with labels under all buttons</phrase>
		</textobject>
	      </mediaobject>
	      
	    </figure>
	  </listitem>
	  
	  <listitem><para>If your toolbar is configured to show labels beside button icons (rather than below them), don't show labels for every button unless the user has selected "text only" mode.  Decide which buttons will be most frequently used, place those first on the toolbar, show the labels only for those buttons, and place separators between each of them to make it clear which label refers to which icon. For example:</para>
	    
	    <figure>
	      <title>Toolbar with labels beside the first few buttons only</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/EvoToolbar.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>Toolbar with labels beside the first few items only</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </listitem>
	  
	  
	  <listitem><para>Ensure toolbar controls have tooltips are displayed when the pointer is paused over a toolbar button. For buttons that directly correspond to menu items, make the tooltip label the same as the menu item name. For toolbar buttons with text labels, make the text label the same as the menu item name.</para></listitem>
	  
	  <listitem><para>Use book title capitalization (also known as "title caps") for toolbar button text and tooltips.  For example, <guilabel>Save As</guilabel>, and <guilabel>Always on Top</guilabel>.  See the section on <link linkend="layout-capitalization">Capitalization</link> for more information.</para></listitem>
	  
	
	</itemizedlist>

      </sect1>

 
      
     
      
<!-- Removed for now until I decide how much/little specific guidance to give for application types

      <sect2>
	<title>Default Toolbar Layout&mdash; Office Application</title>

	<para>However many toolbars or palette windows your application provides, by default there should be one main toolbar that provides a subset of the application's overall functionality.  Many of the buttons on this toolbar will be the same regardless of the type of application.</para>

	<para>The following operations should be included on the main toolbar in the following order, if your application supports them.  Application-specific functions should be slotted onto the toolbar according to the position on which they appear on the main menu bar.  For functions that don't appear on the <guimenu>File</guimenu>, <guimenu>Edit</guimenu> or <guimenu>Help</guimenu> menus, this means they will normally appear between the <guibutton>Replace</guibutton> and <guibutton>Help</guibutton> buttons.</para>

	<figure>
	  <title>Buttons that should appear on the main toolbar of an office application.</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/GtkToolbar_productivitydefault.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>New-Open-Save|Print|Undo-Redo|Find-Replace|Cut-Copy-Paste-Delete</phrase>
	    </textobject>
	  </mediaobject>
	</figure>

	<para>If your application supports all of these functions and you want to simplify your toolbar, consider leaving off the <guibutton>Undo</guibutton> and <guibutton>Redo</guibutton> buttons, or the <guibutton>Cut</guibutton>, <guibutton>Copy</guibutton>, <guibutton>Paste</guibutton> and <guibutton>Delete</guibutton> buttons, as most users prefer to use keyboard or menu for these functions.  However, you should include an option to re-add these buttons in your <menuchoice><guimenu>Toolbars</guimenu><guimenuitem>Customize</guimenuitem></menuchoice>... menu.</para>

	<para>If you wish to add a <guibutton>Help</guibutton> toolbar button, it should be placed last (rightmost, in western locales) on the main toolbar.  However, adding a <guibutton>Help</guibutton> button to the toolbar is not generally recommended, as usability studies suggest that it will be rarely used.  (N.B. This finding applies only to toolbars, not <guibutton>Help</guibutton> buttons in dialogs).</para>
	


      </sect2>
      
      <sect2>
	<title>Default Toolbar Layout&mdash; Browser Applications</title>

	<para>Applications for browsing documents or other objects, such as web, file, help or documentation browsers, should use the following layout for their main toolbar:</para>

	<para>Back Forward [Other Navigation] Stop Reload | Home | [Other App-Specific]</para>
	
	<para>Application-specific buttons (other than navigation buttons) should be placed in the button group following <guibutton>Home</guibutton>, in the order that they appear on the main menu bar.</para>
	
	<para>Following this model, some current GNOME browser apps would have their toolbars re-ordered as follows:</para>

	<figure>
	  <title>Nautilus 1.0 toolbar rearranged to follow recommended standard toolbar layout for browser applications</title>
	  <mediaobject><imageobject>
	      
	      <imagedata fileref="images/GtkToolbar_browserdefault.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Back Forward Up Stop Reload | Home | WebSearch Services</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	
	<table>
	  <title>Proposed toolbar re-ordering for Nautilus</title>
	  <tgroup cols='2' align='left'>
	    	    
	    <tbody>
	      <row>
		<entry>Nautilus (1.0.x)</entry>
		<entry>Back Forward Up Refresh Home WebSearch Services Stop</entry>
	      </row>
	      <row>
		<entry>Nautilus (proposed)</entry>
		<entry>Back Forward Up Stop Reload | Home | WebSearch Services </entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<table>
	  <title>Proposed toolbar re-ordering for Galeon</title>
	  <tgroup cols='2' align='left'>

	    <tbody>
	      <row>
		<entry>Galeon (0.12.x)</entry>
		<entry>Back Forward Reload Home Stop Zoom [URL] Go</entry>
	      </row>
	      <row>
		<entry>Galeon (proposed)</entry>
		<entry>Back Forward Stop Reload | Home | Zoom [URL] Go </entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	
	<table>
	  <title>Proposed toolbar re-ordering for GNOME Help (deprecated, for illustration purposes only)</title>
	  <tgroup cols='2' align='left'>

	    <tbody>
	      <row>
		<entry>GNOME Help (0.4)</entry>
		<entry>Back Forward Refresh Index History Bookmarks Help</entry>
	      </row>
	      <row>
		<entry>GNOME Help (proposed)</entry>
		<entry>Back Forward Stop Reload | Index History Bookmarks</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Note: In browser applications, use <guilabel>Reload</guilabel> rather than <guilabel>Refresh</guilabel> when the data will be actually re-read from its original source, rather than just re-painted on the screen.</para>


      </sect2>
-->

</chapter>
<!-- Note from GJM: I think palettes should go with toolboxes/utility windows. -->
<!--
    <sect1>
      <title>TODO : Palettes</title>
      
      <para>A palette is much like a floating toolbar.  However, its size and shape is usually more customizable, and it typically has a titlebar of its own and appears in the GNOME task list.</para>
      
    </sect1>
  </chapter>
-->

<!--
<chapter id="dialogs">

<title>Dialogs</title>

< ! - - TODO:
- Double-clicking to close a dialog
- - >
	
<sect1 id="dialog-principles">
	
<title>General Principles</title>

<para>
Dialog boxes are windows allowing the user to interact with an application in ways that supplement the main application window. They might typically be used to control the properties of an object, to request further information from the user or to notify the user of an event.
</para>

<para>
Dialog boxes come in a number of different forms, suitable for different situations, and each with their own UI implications.
</para>

<sect2 id="dialogs-types">

<title>Types of dialog boxes</title>

<sect3 id="dialogs-modal-and-modeless">

<title>Modal and modeless dialog boxes</title>

<para>
All dialogs can be classified according to whether they are modal or modeless. Modal dialog boxes are those which prevent the user from interacting with any other part of the application while they are visible. They should be used only where it is necessary that the user doesn't make any changes to the state of the application before performing an action with the dialog or closing it.
</para>

<para>
Modeless dialog boxes allow the user to continue to interact with the rest of the application while the dialog is visible. They are generally suitable for tasks such as changing the properties of an object or tool.
</para>

<para>
In general, modeless dialogs are preferable to modal dialogs since they are less intrusive. Dialogs should only be made modal if there is a compelling reason to do so.
</para>

</sect3>

<sect3 id="dialogs-informational">

<title>Informational dialog boxes</title>

<para>
Informational dialog boxes are those which do not require the user to enter any data or make choices; they are merely for notification purposes.  These dialogs typically only need a label for the user to read and a button to close the dialog. They can be modal or modeless as appropriate.
</para>

</sect3>

<sect3 id="dialogs-druids">

<title>Druids</title>

<para>
Druids are dialog boxes which lead the user through a sequence of steps. They are frequently used for software installation and configuration, though they are by no means limited to this role.
</para>

<para>
Druids are best suited to situations in which the user requires some sort of hand-holding, due to the way in which they can combine documentation and functionality. Experienced users tend to find them inefficient and patronising.
</para>

<para>
GNOME's druids are roughly equivalent to the <quote>Wizards</quote> frequently found in Microsoft Windows.
</para>

</sect3>

</sect2>

<sect2 id="dialogs-layout">

<title>Dialog box layout</title>

<para>
Note that the left-right positioning of items described here only applies to Western systems. Localisation for other countries may change these positions.
</para>

<para>
The top portion of a dialog box should contain the main area, the content of which is very much up to the developer.
</para>

<para>
At the bottom of the dialog window should be a single row of buttons which pertain to the whole dialog. These can be divided into four main types: Action buttons, closing buttons, navigation buttons and help buttons.
</para>

<para>
These buttons should be laid out as follows: Action or navigation buttons should be on the extreme right. Closing buttons should be to the left of any action or navigation buttons. A help button should be on the extreme left.
</para>

</sect2>

<sect2 id="dialogs-behaviour">

<title>Dialog box behaviour</title>

<para>
Dialogs should reflect the current state of the application. If changes are made to the state of the application while the dialog is on the screen then these changes should be immediately visible in the dialog.
</para>

<para>
Care should be taken to ensure that it is obvious to the user whether changes made within the main area will immediately affect objects external to the dialog or whether the user will have to perform another action to apply those changes. For example, the presence of a button labeled <guibutton>Apply</guibutton> would imply that any changes would only be applied once that button had been pressed, while the presence of only a button marked <guibutton>Close</guibutton> would imply that changes were applied immediately.
</para>

<para>
Nothing in the main area of the dialog should dismiss the dialog. Any actions which will dismiss the dialog should be confined to the bottom row of buttons.
</para>

</sect2>

<sect2 id="dialogs-buttons">

<title>Dialog box buttons</title>

<para>
These dialogs should be positioned on the bottom row of the dialog according to the rules specified above. Action and navigation buttons should only be enabled while it makes sense for the user to press them. Closing buttons should always be enabled; it should always make sense for the user to press them.
</para>

<sect3 id="dialogs-buttons-action">

<title>Action buttons</title>

<para>
Most dialogs will have buttons to perform some kind of action. These should be labelled with a verb to describe the action. (Labels such as <guibutton>OK</guibutton>, <guibutton>Yes</guibutton> and <guibutton>No</guibutton> are discouraged since they are difficult for the user to quickly scan for the desired action.) The leftmost action button should be the default button, and so be activated by the Enter key in addition to any other accelerators it may possess.
</para>

<para>
On modal dialogs the action button should also close the dialog. On modeless dialogs either all action buttons should close the dialog or none should.
</para>

</sect3>

<sect3 id="dialogs-buttons-closing">

<title>Closing buttons</title>

<para>
Closing buttons vary depending on the type of dialog on which they appear. On dialogs which are closed by their action buttons there should be a Cancel button which should close the dialog and return the application to the state it was in before the dialog was shown.
</para>

<para>
On dialogs which are not closed by their action button there should be a Close button which should close the dialog without making any further changes to the state of the application.
</para>

<para>
The situation is slightly different again for informational dialogs. As always, the closing button should close the dialog, but the labelling of the button is a decision for the developer and is dependent upon the context in which it appears. As a rough guide, <guibutton>Close</guibutton> will generally be an appropriate label for dialogs appearing in response to a user's request for information, while <guibutton>OK</guibutton> will often be more appropriate for unrequested alerts.
</para>

<para>
In all of these cases the closing button should be activated by the escape key. On purely informational dialogs where the dismiss button is the only button in the bottom row of the dialog, it should also be the default button and so be activated by the Enter key.
</para>

</sect3>

<sect3 id="dialogs-buttons-navigation">

<title>Navigation buttons</title>

<para>
If the dialog contains a sequence of steps (as in a druid, for example), they should be navigable with <guibutton>Next</guibutton> and <guibutton>Previous</guibutton> buttons.
</para>

</sect3>

<sect3 id="dialogs-buttons-help">

<title>Help buttons</title>

<para>
Developers are encouraged to give their dialogs a <guibutton>Help</guibutton> button. This should launch the default help browser with the section of the application's help document relevant to the current dialog.
</para>

</sect3>

</sect2>

<sect2 id="dialogs-window-titles">
<title>Dialog Window Titles</title>

<para>
Dialog windows should be given titles that enable the user to determine from the title alone both the task that the dialog is intended to carry out and the parent window (if any) that the task applies to. So, for example, the title for a search and replace dialog in a text editor should look something like: <guilabel>Replace in document.txt</guilabel>.
</para>

</sect2>

</sect1>

<sect1 id="standard-dialogs">
	
<title>Standard Dialogs</title>

<para>
GNOME provides a number of standard dialogs which should be used wherever appropriate.
</para>

<sect2>

<title>File Selector</title>

<para>
The file selector should be used whenever the user is required to select one filename, either of a file that already exists or the desired name of a file that is to be created.
</para>

<para>
If the file selector is being used to select a file that is to be opened in the application then its title should be <guilabel>Open File</guilabel>. If it is being used to choose a filename to save a file to then its title should be <guilabel>Save File</guilabel>.
</para>

<para>
Sometimes it may be appriate to extend the file selector to include new features. For example, if an application is capable of saving a document in multiple different file formats then the file selector should include a mechanism for selecting the desired file type.
</para>

</sect2>

<sect2>

<title>Font Selector</title>

<para>
The font selector should be used wherever the user has to select a font. If the font is being selected for a particular document then the dialog should be titled <guilabel><replaceable>docname</replaceable>: Pick a Font</guilabel>, otherwise it should be titled <guilabel><replaceable>appname</replaceable>: Pick a Font</guilabel>.
</para>

</sect2>

<sect2>

<title>Color Selector</title>

<para>
The color selector should be used wherever the user has to select a color. If the color is being selected for a particular document then the dialog should be titled <guilabel><replaceable>docname</replaceable>: Pick a Color</guilabel>, otherwise it should be titled <guilabel><replaceable>appname</replaceable>: Pick a Color</guilabel>.
</para>

</sect2>

</sect1>

</chapter>
-->

<!-- commented out for Nov 23 draft, we can re-enable when there's something there - seth
<chapter id="feedback">
    <title>Feedback</title>
    <para>FIXME</para>
</chapter>
-->
<chapter id="controls">

<title>Controls</title>

<para>
The GNOME environment provides a set of controls (also known as widgets<!-- FIXME: which should we use? -->) for use in your applications. It is important that controls are used appropriately and that they follow standard behaviours since this allows users to predict the effects of their actions. Controls which behave in non-standard ways dilute the meaning of the GUI's visual language.
</para>

<para>
Under some circumstances the value that a control manipulates may not have an effect, or the action that a control activates may not be able to run. At these times the control should be made unavailable. While a control is unavailable it will appear dimmed and will not be able to receive the focus.
</para>

<sect1 id="controls-buttons">

<title>Buttons</title>

<para>
Buttons should be used to initiate actions.
</para>

<para>
Buttons should generally be labeled with verbs. Button labels should have the first letter of the first word and of any significant words capitalized. Where the action will require further input from the user before it can be carried out, the label should end with an ellipsis ("...").
</para>

<para>
In a dialog, one button may be made the default button. The guidelines for doing this are in the section on dialogs.
</para>

</sect1>

<sect1 id="controls-toggle-buttons">

<title>Toggle Buttons</title>

<para>
Toggle buttons are buttons which remain depressed after they have been clicked on. They can be used to indicate a currently active mode, and should work in the same manner as either radio buttons or check boxes. They may be raised either by a second click, or by another toggle button in the same group being clicked on.
</para>

<para>
Toggle buttons should generally only be used where there is little available space, such as on toolbars or palettes. Otherwise check boxes or radio buttons will be more appropriate.
</para>

</sect1>

<sect1 id="controls-check-boxes">

<title>Check Boxes</title>

<para>
Check boxes are used to toggle an option on or off. Check box options should be independent of each other. Toggling a check box should not affect the values of other controls. 
</para>

<para>
Toggling a check box may affect the availability of other controls. Where this happens, the check box should ideally be placed immediately above or to the left of the controls it affects, in such a way as to indicate that the controls are dependent on the state of the check box.
</para>

<para>
While a check box option may be applied instantaneously, changing it should not initiate an action.
</para>

<para>
Check boxes should be labeled in a way that unambiguously indicates what the effects of both their checked and unchecked states will be. Where this cannot be done, it may be better to use two radio buttons so that both states can be given labels.
</para>

</sect1>

<sect1 id="controls-radio-buttons">

<title>Radio Buttons</title>

<para>
Radio buttons are used in groups to select from a mutually exclusive set of options. Only one radio button within a group may be checked at any one time. As with check boxes, radio buttons should not be used to initiate actions.
</para>

</sect1>

<sect1 id="controls-option-menus">

<title>Option Menus</title>

<para>
Option menus are used to select from a mutually exclusive set of options. They should not be used to initiate actions.
</para>

<para>
In general, radio buttons are preferable to option menus, since options menus only display the currently selected item. However, their use may be appropriate when there is little available space or where the list of options may change.
</para>

</sect1>

<sect1 id="controls-combo-boxes">

<title>Combo Boxes</title>

<para>
Combo boxes combine a text entry field and a menu of predefined values. Selecting one of the pre-defined values from the menu should update the contents of the text field to that value and may also perform the action that would be performed if the user pressed the Return key in that text field.
</para>

</sect1>

<sect1 id="controls-progress-bars">

<title>Progress Bars</title>

<para>
Progress bars are visual indicators of the progress of a task being carried out by the application. <!-- would it be good to have a section on feedback? -->
</para>

<para>
There are two types of progress bar: Determinate progress bars, which indicate what proportion of the task has been completed, and indeterminate progress bars, which indicate only that the application is working on a task. Where the length of a task is known, a determinate progress bar should be used. Otherwise, an indeterminate progress bar should be used.
</para>

</sect1>

<sect1 id="controls-status-bars">

<title>Status Bars</title>

<para>
Status bars provide a small area which can be used to display one line of text describing the status of the application. Status bars should always be positioned at the bottom of a window.
</para>

<para>
Status bars should only contain information which it is not critical that the user sees. Important information should be presented to the user by other means.
</para>

</sect1>

</chapter>

<chapter id="layout">

<title>Layout and Appearance</title>

<!-- TODO:
- More than any other section this needs to be liberally sprinkled with examples
-->

<para>
The layout of a GUI is important both because it communicates the relationships between elements, and because an aesthetically-pleasing interface is more pleasant to use.
</para>

<sect1 id="layout-order-relationships">

<title>Order and Relationships</title>

<para>
Western users are accustomed to reading from the top-left to the bottom-right. For this reason, elements of an interface which are intended to be presented to the user in a specific order should be laid out in such a way that the first element the user should encounter is in the top-left and the last in the bottom-right.
</para>

<para>
(Bear in mind that when localized for non-western locales, interfaces may be reversed so that they read from right to left.) <!-- Does it get more complex than this? -->
</para>

<para>
Relationships between elements are usually indicated by their positions. Labels should be placed either above or to the left of the controls they relate to.
</para>
      
<!-- CFB: I just copied in this figure from the accessibility guide... feel free to edit/delete as you see fit...-->

      <figure id="label-placement-example">
	<title>Correct label placement for various GUI elements</title>
	<informaltable frame="all">
	  <tgroup cols="3" align="center">
	    <tbody>
	      <row>
		<entry valign="middle">
	          <mediaobject>
		    <imageobject>
		      <imagedata fileref="images/label_above.png" format="PNG"/>
		    </imageobject>
		    <textobject>
		    <phrase>List control with label above</phrase>
		  </textobject>
		  </mediaobject>
	  List control with label above
	        </entry>
		
		<entry valign="middle">
	          <mediaobject>
		    <imageobject>
		      <imagedata fileref="images/label_below.png" format="PNG"/>
		    </imageobject>
		    <textobject>
		      <phrase>Large file manager icon with label underneath</phrase>
		    </textobject>
		  </mediaobject>
	  Large file manager icon with label underneath
	        </entry>
		
		<entry valign="middle">
	          <mediaobject>
		    <imageobject>
		      <imagedata fileref="images/label_right.png" format="PNG"/>
		    </imageobject>
		    <textobject>
		    <phrase>Small toolbar icon with label to its right</phrase>
		  </textobject>
		  </mediaobject>
	  Small toolbar icon with label to its right
	        </entry>
		
		<entry valign="middle">
         	  <mediaobject>
		    <imageobject>
		      <imagedata fileref="images/label_left.png" format="PNG"/>
		    </imageobject>
		    <textobject>
		    <phrase>Spinbox control with label to its left</phrase>
		  </textobject>
		  </mediaobject>
	  Spinbox control with label to its left
        	</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </figure>
      
    </sect1>

<sect1 id="layout-aesthetics">

<title>Aesthetics</title>

<para>
Simply making a GUI look tidier can make it seem less intimidating. This can be done by aligning elements with each other and by removing unnecessary elements.
</para>

<para>
GUI's are rarely pleasant to look at when the elements are densely packed onto the screen, and for this reason the elements in a GUI should be given adequate space between each other. The space between elements is frequently referred to as <wordasword>white space</wordasword>.
</para>

</sect1>

<sect1 id="layout-grouping-separators">

<title>Grouping and Separators</title>

<para>
There is a rule, frequently referred to in interface design, called the 7+/-2 rule. It states that humans can only hold between 5 and 9 items of information in their minds at a time. One of the implications of this in interface design is that long lists of choices should, where possible, be broken down into smaller groups of choices.
</para>

<para>
There are a number of ways of visually dividing controls into groups. One method is to use separators and frameboxes to draw lines and boxes between elements. Another method is to use a greater amount of white space between groups of elements.
</para>

<para>
It is essential that the extent of option groups such as radio buttons be made clear, using these methods as appropriate.
</para>

</sect1>


    <!-- Colors, Fonts and Accessibility -->
    <sect1 id="colors-fonts">
      <title>Fonts and Text</title>
      
      <para>To a user with normal vision, textual output provides the majority of the information and feedback in most applications.  To a visually-impaired user who may not be able to see or understand any additional graphical output, clear textual output is critical.  It is therefore essential that you choose and position text carefully on the screen, and leave the choice of fonts and sizes to the user, to ensure that all users are able to use your application effectively.</para>
      
      <para>Don't mix lots of different fonts and sizes in your application, it will just look unprofessional and be harder to read.  If you need to use different fonts for different types of information, don't use more than two or three in the same window, and choose visually distinct rather than similar-looking fonts.  In general, you should always use fonts from the current theme, and specify relative rather than absolute font sizes.</para>
      
      <para>&lt;pics&gt;</para>

      <para>Recommendations:</para>
      
      <itemizedlist>
	<listitem><para>Don't hard-code font styles and sizes. The user should be able to adjust all sizes and typefaces. If for some reason you cannot make this functionality available, never hardcode any font sizes smaller than 10 points.</para></listitem>
	
	<listitem><para>Don't use graphical backdrops or &quot;watermarks&quot; behind text, other than those specified by the user's chosen theme. Such images interfere with the contrast between the text and its background.  This can cause difficulty for users with visual impairments, who will therefore normally choose themes that always use plain backdrops.</para></listitem>
	
	<listitem><para>Position labels consistently throughout your application. This normally means immediately below large icons, immediately to the
right of small icons, and immediately above or to the left of other controls. See <link linkend="label-placement-example">label positioning example</link>.</para></listitem>

	<listitem><para>When you use static text to label a control, ensure that the label immediately precedes that control in the Tab order. This will ensure that the access key (underlined character) you assign to the label will move focus to or activate the correct control when pressed.</para></listitem>
	
     
	<listitem><para>Label objects with names that make sense when taken out of context. Users relying on screenreaders or similar assistive technologies will not necessarily be able to immediately understand the relationship between a control and those surrounding it.</para></listitem>
	
	<listitem><para>When you use static text to label a control, end the label with a colon. For example, <guilabel>Email:</guilabel> to label a text field into which the user should type their email address. This helps identify it as a control's label rather than an independent item of text.</para></listitem>

	<listitem><para>Don't use the same label more than once in the same window. If you use the same label in different windows, it will help if it means the same thing in both windows. Also, don't use labels that are spelled differently but sound the same, e.g. &quot;Read&quot; and &quot;Red&quot;, as this could be confusing for users relying on screenreaders.</para></listitem>

	<listitem><para>Provide alternatives to WYSIWYG. Some users may need to print text in a small font but edit in a larger screen font, for example. Possible alternatives include displaying all text in the same font and size (both of which are chosen by the user); a &quot;wrap-to-window&quot; option that allows you to read all the text in a window without scrolling horizontally; a single column view that shows the window's contents in a single column even if they will be printed in multiple columns; and a text-only view, where graphics are shown as placeholders or text descriptions.</para></listitem>
      </itemizedlist>

      <sect2 id="layout-capitalization">
	
	<title>Capitalization</title>

	<para>Two different styles of capitalization are used in a GNOME user interface:</para>
	
	<orderedlist>
	  
	  <listitem><para>Book title capitalization (or "title caps") means capitalizing the first letter of the first and last words.  Also, capitalize all words inbetween, except:</para>
	  
	    <itemizedlist>
	      <listitem><para>Articles (a, an, the...)</para></listitem>
	      
	      <listitem><para>Conjunctions (and, but, for, not, so, yet...)</para></listitem>
	      
	      <listitem><para>Prepositions of four or fewer letters (at, for, with, into...)</para></listitem>
	  
	    </itemizedlist>
	    
	  </listitem>
	  
	  <listitem><para>Sentence-style capitalization (or "sentence caps") means capitalizing the first letter of the first word, and any other words normally capitalized in sentences, such as proper nouns.</para></listitem>
	
	</orderedlist>
	
	<para>The table below tells you what sort of capitalization to use for which GUI elements.</para><table frame='all'>
	  
	  <title>Capitalization styles for different GUI elements</title>
	  <tgroup cols='3' align='left'>

	    <thead>
	      <row>
		<entry>Element</entry>
		<entry>Style</entry>
		<entry>Example</entry>
	      </row>

	    </thead>

	    <tbody>

	      <row>
		<entry>Alt (alternate) text on web pages</entry>
		<entry>Sentence</entry>
		<entry>Screenshot showing sample panel layout</entry>
	      </row>
	      <row>
		<entry>Button labels (except radio buttons)</entry>
		<entry>Title</entry>
		<entry>Find Now</entry>
	      </row>
	      <row>
		<entry>Checkbox labels</entry>
		<entry>Sentence</entry>
		<entry>Don't show this again</entry>
	      </row>
	      <row>
		<entry>Column headings</entry>
		<entry>Title</entry>
		<entry>File Type</entry>
	      </row>
	      <row>
		<entry>Filenames</entry>
		<entry>Sentence</entry>
		<entry>Untitled.txt</entry>
	      </row>
	      <row>
		<entry>Frame/group labels</entry>
		<entry>Sentence</entry>
		<entry>Desktop background</entry>
	      </row>
	      <row>
		<entry>Icon labels</entry>
		<entry>Title</entry>
		<entry>Time Tracking Tool</entry>
	      </row>
	      <row>
		<entry>List entries</entry>
		<entry>Sentence</entry>
		<entry>Copy to next workspace</entry>
	      </row>
	      <row>
		<entry>Menu titles and menu items</entry>
		<entry>Title</entry>
		<entry>Save As...</entry>
	      </row>
	      <row>
		<entry>Messages</entry>
		<entry>Sentence</entry>
		<entry>No matches found.</entry>
	      </row>
	      <row>
		<entry>Radio button labels</entry>
		<entry>Sentence</entry>
		<entry>Embossed logo</entry>
	      </row>
	      <row>
		<entry>Status bar text</entry>
		<entry>Sentence</entry>
		<entry>File download complete</entry>
	      </row>
	      <row>
		<entry>Tab titles (notebooks)</entry>
		<entry>Title</entry>
		<entry>Panel Objects</entry>
	      </row>
	      <row>
		<entry>Text box labels</entry>
		<entry>Sentence</entry>
		<entry>First name:</entry>
	      </row>
	      <row>
		<entry>Titlebar text</entry>
		<entry>Title</entry>
		<entry>Text Properties</entry>
	      </row>
	      <row>
		<entry>Toolbar button labels</entry>
		<entry>Title</entry>
		<entry>Print Preview</entry>
	      </row>
	      <row>
		<entry>Tooltips - menu items</entry>
		<entry>Sentence</entry>
		<entry>Insert special characters into documents</entry>
	      </row>
	      <row>
		<entry>Tooltips - toolbar controls</entry>
		<entry>Title</entry>
		<entry>Save As</entry>
	      </row>
	      <row>
		<entry>Webpage titles and navigational elements</entry>
		<entry>Title</entry>
		<entry>Return to Homepage</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>


      </sect2>


    </sect1>
    
    <sect1>
      <title>Color and Contrast</title>

      <para>Poor choice of colors on the screen can cause problems for users with color blindness (for whom hue is important) or low-vision (for whom brightness/contrast is important). For example, some users require a high level of contrast between the background and text colors&mdash; black on white, white on black, or some other high-contrast combination. Others can experience discomfort unless they use low contrast settings, such as gray text on a lighter gray background.</para>

      <para>It is therefore vital that you allow the user to customize the colors in any part of your application that conveys important information.  Normally, this means you should only use colors that are part of the user's chosen theme.  If you have to use any extra colors, they must be customizable in your application's <guilabel>Preferences</guilabel> dialog.</para>
      
      <figure id="redundant-color-example"> <title>Example illustrating redundant use of color</title>
	<informaltable frame='all'>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry valign='middle'> 
		  <mediaobject>
		    <imageobject>
		      <imagedata fileref="images/colour_only.png" format="PNG"/>
		</imageobject>
		  <textobject>
		    <phrase>Example showing changes in stock price using color only</phrase>
		  </textobject>
		</mediaobject>
		</entry>
		
		<entry>This display could cause problems for a red-green colorblind user (colorblindness affects as many as 1 in 7 males in some parts of the world).  The lack of contrast between the red text and black background would also make it hard to read for a user with low vision, even with a screen magnifier.</entry>
	      </row>
	      
	      <row>
		<entry valign='middle'>
		  <mediaobject>
		    <imageobject>
		      <imagedata fileref="images/colour_and_arrows.png" format="PNG"/>
		</imageobject>
		  <textobject>
		    <phrase>Example showing changes in stock price using both color and arrows</phrase>
		  </textobject>
		</mediaobject>
		</entry>
		
		<entry>This display reinforces the color coding with arrows to show the stock price movement, and uses darker shades of green and red on a lighter background to provide higher contrast.  This needn't be the default colour scheme if testing were to show it to be too distracting for the majority of users, but it should be possible to customize it in this way either by theming or via the application's <guilabel>Preferences</guilabel> dialog.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </figure>
      
      <para>Always design colored elements, such as icons, in black and white first, then add the color later.  If the design works in black and white, you can be fairly sure that the color you add will be redundant, and used only to reinforce the black and white design.  See <link linkend="icons">Icons</link> for more information.</para>
      
      <para>Recommendations:</para>
      <itemizedlist>

	<listitem><para>Only use colors from the user's currently-selected theme in your application.  If for some reason you do need to use colors that are not available in the theme, make those colors customizable within your application's <guilabel>Preferences</guilabel> dialog.  Never hard-code application colors, as some users need to use particular combinations of colors and levels of contrast to be able to read the screen comfortably.</para></listitem>

	<listitem><para>Ensure your application is not dependent on a particular theme. Test it with different themes (including high contrast accessibility themes, which use fewer colors) to ensure your application respects the settings.</para></listitem>

	<listitem><para>Don't use color as the only means to distinguish items of information. All such information should be provided by at least one other method, such as shape, position or textual description. See <link linkend="redundant-color-example">color and contrast example</link> above.</para></listitem>

      <listitem><para>Support high contrast GNOME themes (when these become available). Ensure that when one of these themes is selected, all the text in your application appears in the high contrast foreground and background colors specified by the theme.</para></listitem>

      
      </itemizedlist>

    </sect1>
    
  </chapter>
  <chapter id="icons">
    <title>Icons</title>
    <para> </para>
    <para>Icons are a graphical metaphor presenting a visual image that the user associates with a particular object, state or operation. Good icons suggest to the user the sort of conceptual item they are associated with, whether that be an application in the panel menu or the "right aligned" state in a word processor toolbar.</para>
    
    <sect1 id="specifications">
      <title>Specifications for GNOME icons</title>
      
      <sect2 id="toolbar_icons">
	<title>Toolbar and Menu Icons</title>
	
	<formalpara><title>Perspective and Lighting</title><para>Toolbar and menu icons should have the perspective of being viewed head on, as if they were sitting in front of the user at eye-level. This gives toolbars a "flat" appearance that complements their shelf-like nature. Lighting should come from a point well above the user's head, casting a small shadow down.</para></formalpara>
	<formalpara><title>Shape</title><para>Make sure that sets of toolbar icons used together are easy to differentiate. Try looking at the silhouettes of toolbar icons that may be used together to ensure that they are visually distinct.</para></formalpara>
	<figure>
	  <title>Silhouette of the toolbar icons from the Nautilus Crux theme</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/toolbar-silhouette.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Silhouettes of the various toolbar icons</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	<formalpara><title>Size</title><para>Toolbar icons should be 24x24 pixels. Menu icons should be 16x16 pixels.</para></formalpara>
	
	<figure>
	  <title>Sample toolbar icon: 'Save'</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/save-icon.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>floppy disk</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	<figure>
	  <title>Sample toolbar icon: 'Print'</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/print-icon.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Printer</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	
	<sect3 id="stock_toolbar_icons">
	  <title>Stock Icons</title>
	  <para>Often, you will not have to design any toolbar icons yourself. Gtk provides many stock icons, and you should use these whenever you provide a toolbar button for one of the functions they represent. This establishes consistent language across applications, and makes it easier for users to search for items on the toolbar. Do not use stock toolbar icons for anything other than their intended purpose, however, as this will make your application inconsistent with others, and could easily confuse your users.</para>
	  <para>To browse the available stock icons, install the development packages for GTK version 1.3 or 2.x and run <command>gtk-demo</command>. Double click on <guimenuitem>Stock Item and Icon Browser</guimenuitem> to activate the stock icon browser. Note that icons vary in available resolution, so the images presented in the icon browser should not be taken as indicative of the maximuum quality of an image. To view the images in PNG format, look in the GTK 2 source code under <filename class="directory">gtk/stock-icons</filename>.</para>
	</sect3>
      </sect2>

      <sect2 id="application_icons">
	<title>Application Icons</title>
	<formalpara><title>Perspective and Lighting</title><para>Application icons should have the perspective of being placed on a table in front of the user. Light should come from the upper left corner, casting shadows onto the top of the imaginary table.</para></formalpara>
	<formalpara><title>Shape</title><para>Application icons should be shaped (rather than being square or a rectangle) in order to be visually appealing, but need not adhere to particular shape specifications.</para></formalpara>
	<formalpara><title>Size</title><para>Application icons should be 48x48 pixels, but should be test viewed at smaller sizes to ensure they scale well.</para></formalpara>
	<figure>
	  <title>A great icon for a software installer</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/installer-icon.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>A software box with a diskette and a cd next to it</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	<figure>
	  <title>A reasonable icon for an IDE</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/gide-icon.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>A hammer</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </sect2>
      <sect2 id="document_icons"><title>Document Icons</title>
	<formalpara><title>Perspective and Lighting</title><para>Document icons should have the perspective of being placed on a table in front of the user. Light should come from the upper left corner, casting shadows onto the top of the imaginary table.</para></formalpara>
	<formalpara><title>Shape</title><para>Document icons have no specific shape requirements. When a document type corresponds to a specific application, one option is to use a piece of paper with the application icon on it as the document icon. A better option is to portray the type of the file directly, for example a good icon for MPEG video would be a movie reel. Also remember that document icons are likely to be used in conjunction with a variety of different themes and should not be customized to one particular theme or another.</para></formalpara>
	<formalpara><title>Size</title><para>Document icons should preferably be made in at least three sizes 24x24, 48x48 and 96x96 pixels. 48x48 is the most commonly used in the file manager, however the other two are important in various contexts. Because they are primarily viewed in the Nautilus file manager, which allows for a variety of other sizes, liberty should be taken to provide icons in as many different sizes as the artist has time for.</para></formalpara>
      </sect2>
    </sect1>


    <sect1 id="design">
      <title>Designing Effective Icons</title>
      <para>
	Icons have many uses. Icons can assist the user in rapidly scanning a large number of objects to select the desired item. Particularly after a user is acustomed to an icon's appearance, they can identify it more rapidly than a text label. Icons can augment text, for example in a menu, in communicating the purpose of an item by providing visual suggestions to accompany the descriptive text. It is often true that a picture, even a very small one, is worth a thousand words. Icons can provide a compact representation for a large number of functions when there is insufficient space to display textual descriptions. This is evident in toolbars where icons are often used without text to reduce space usage, or when icons are placed on a small panel.
      </para>
      <para>
	<tip><title>Rule of Thumb for Icon Metaphors</title><para>"If you have to think about an icon to 'get it', the metaphor is too complex"</para></tip>
      </para>

      <sect2 id="graphic_design">
	<title>Graphic Design</title>

	<para>Blah blah, notes on graphic design of icons, blah blah, icons should be high contrast, distinct, etc etc</para>

	
	<tip><title>Accessibility note</title><para>Try designing in monochrome, and adding color later. This way you can be sure your design doesn't rely on color, which is important for users running on displays with a limited depth, and for users with certain vision impairments.</para></tip>	
	<!-- CFB note to seth: Actually this isn't so much an accessibility note as a general "good visual design note".  In general, I'd also rather not call out 'accessibility issues' separately, as it might tempt people just to ignore them because "it doesn't affect me"... a good UI design will be inherently accessible anyway -->


      </sect2>

      <sect2 id="right_kind">
	<title>Kinds of Icons</title>
	<para>If at all possible, a <link linkend="functionally_suggestive">functionally suggestive</link> icon should be used. Failing that a <link linkend="name_suggestive">name suggestive</link> icon can be an appropriate choice. <emphasis><link linkend="text_icons">Text icons</link> and other desperate substitutes should not be used</emphasis>.</para>
	
	<itemizedlist>
	  <listitem><para id="functionally_suggestive"><emphasis role="bold">Functionally Suggestive Icons</emphasis></para>
	    <para>Icons should be, if possible, suggestive of the functionality with which they are associated. The best icon will suggest to the user the primary purpose of the program or operation without having to read accompanying text. Users tend to recognize functionally suggestive icons more rapidly than other forms because they directly associate with a physical object or action.</para>
	    <figure>
	      <title>A functionally suggestive icon for a word processor (AbiWord)</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/abiword-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>A document with a pen writing on it</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	    <figure>
	      <title>A functionally suggestive icon for underline</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/underline-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>An underlined character</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </listitem>
	  <listitem><para id="name_suggestive"><emphasis role="bold">Name Suggestive Icons</emphasis></para>
	    <para>Some icons, such as the Nautilus icon, do not suggest the program's purpose, but instead suggest the program's name. This is less desirable than a functionally suggestive icon, because an extra layer of abstraction is added (rather than associating file management with an icon representing files, they have to represent file management with nautilus with an image of a nautilus shell). Additionally it makes it difficult for new users because, for example, may not know what "Nautilus" is, and hence will not look for a shell when they want to manage files.</para>
	    <figure>
	      <title>A name suggestive icon for Nautilus</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/nautilus-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>A picture of a nautilus shell</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </listitem>
	  <listitem><para id="text_icons"><emphasis role="bold">Text Icons</emphasis></para>
	    <para>Icons which contain the text of the program name in the icon. They effectively contain no metaphor or picture for the user to identify with, and are probably harder to read than the accompanying caption. Since icons draw the eyes, an icon that is harder to identify than text is potentially worse than no icon at all. Hence "text icons" should not be used. Moreover, text should be avoided in icons because it makes the icons difficult to translate. If there is text in icons it should not form words in your native language, a good metric for ensuring that the particular text is not lending to the meaning of the icon.</para>
	    <figure>
	      <title>A text icon for GEdit</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/gedit-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>The GEdit icon</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </listitem>
	  <listitem><para><emphasis role="bold">Random Icons</emphasis></para>
	    <para>Random icons appear to have no association with the program (except perhaps some odd connection in the mind of the developer). These icons should <emphasis>never</emphasis> be used and will likely serve to confuse the user more than help them. The icon's purpose should not be to "look pretty"; this is merely a very desirable side effect. The sodipodi logo is a squirrel, which they show as their icon. However, because the logo has no obvious connection <emphasis>to a user</emphasis> it is a poor icon. Make sure that you are not relying on information that users won't necessarily posses.</para>
	    <figure>
	      <title>A seemingly random icon for SodiPodi</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/sodipodi-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>A squirrel</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </listitem>
	</itemizedlist>
      </sect2>
      <sect2>
	<title>Communicating concept with effective visual language</title>
	<para>...</para>
      </sect2>
      
      
      <sect2>
	<title>Icon Problems to Avoid</title>
	<formalpara><title>Extraneous information</title>
	  <para>Remember that icons will often be viewed in a smaller form. Too much information may render the icon unintelligable when it is shrunk in size (e.g. to be placed on a panel, or in the tasklist). Too much information also makes it easier for users confuse the purpose of the application. For example, in user testing many users thought the Evolution icon would launch a word processor. They were thrown off by the pencil and the paper, which could be seen as extraneous information: it is implicit that the mail program will allow you to write messages as well as receive them. A better icon might have been a simple envelope. Foremost in the icon designer's mind should be a consideration of the minimal visual element(s) necessary to express the purpose of the program.
	  </para>
	</formalpara>
	<figure>
	  <title>Extraneous information - the Evolution icon</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/evolution-icon.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>The Evolution icon</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	<para>
	  The Gnumeric icon is a great icon except for the introduction of extra visual noise. The extra sheet of paper with the 'g' on it behind the spreadsheet and chart adds no significant value to the icon and provides extra visual distraction. In this case the contribution of the extraneous element to the appearance of the icon is (debately) negative. Simple well balanced icons tend to look more attractive than cluttered icons. An improved icon might contain only the spreadsheet and chart; larger because they can use all of the space in the icon, and hence more visually distinct.
	</para>
	<figure>
	  <title>Extraneous information - the Gnumeric icon</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/gnumeric-icon.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>The Gnumeric icon</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	<formalpara><title>Use of body parts</title>
	  <para> Because GNOME aims to be an international desktop, it needs to avoid imagery that is potentially offensive or crass imagery to other cultures. A prime source of offensive imagery is various body parts in a number of different configurations. Aside from offensive gestures with the hands, arms or fingers; body parts that are considered "clean" in one culture (such as eyes), will be considered tasteless or gross to another (such as a nose). Based on a survey of icons in GNOME, body parts frequently appear in the least communicative icons (often "pointing" at some element in the icon); they are being used as an ineffective crutch for poor metaphor. In these situations body parts should <emphasis>not</emphasis> be used. Even in situations where the metaphor is appropriate (for example an eye representing the sawfish appearance capplet) it is better to avoid using a body part. Often body parts have been used in GNOME to suggest a human "choosing" or "using" something. This is normally an unnecessary point for the icon designer to make. People naturally attempt to understand objects in reference to themselves (show someone a bat and they will think of hitting something with the bat, show someone a tool and they will think of using it, etc). For example, the font selector shows a finger pointing to an "F" suggesting the user choosing between a series of fonts. A better icon would be the text "Aa" presented in an ornate font (calling attention to the font rather than the text). The user doesn't need to be told that they are "choosing" the font, they can infer that easily.
	    <figure>
	      <title>Using body parts - the font selector icon</title>
	      <mediaobject>
		<imageobject>
		  <imagedata fileref="images/fontsel-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>The Font Selector Icon</phrase>
		</textobject>
	      </mediaobject>
	    </figure>	    
	    <figure>
	      <title>A better icon for the Font Selector</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/fontsel-suggestion.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>A simple replacement icon showing an ornate "Aa"</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </para>
	</formalpara>
	<formalpara><title>Icons based off puns and word games</title>
	  <para>This should be avoided for a couple reasons, the most obvious of which is that puns do not translate well. For example, representing the "system log monitor" as a log will likely be uncommunicative in languages other than English. Additionally, most users do not comprehend the word play until it is too late for the icon to assist them. Even after being familiar with the "system log monitor" being represented as a log, users do not form the association fast enough for the icon to assist through in scanning through menu entries. A popular instance of this problem was the proliferation of icons representing the "World Wide Web" as a spider web in the mid 1990s. Part of the value of icons is that they bypass linguistic comprehension and hence are complementary to captions, allowing users to utilize more areas of the mind than linguistic recognition (already used in scanning for captions) when they hunt for items.
	    <figure>
	      <title>Word play - System Log Monitor icon</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/log-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>A tree log</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </para>
	</formalpara>
	<formalpara><title>Violent Imagery</title>
	  <para>Just as words like "kill" and "slay" are inappropriate in interfaces, violent or destructive icons should be avoided. The "shut down" icon uses the image of an explosive detonation switch, presumably trying to convey the idea of ending something abruptly. However, this icon is likely to intimidate some users of the computer who will not want to click on the icon for fear of breaking something.
	    <figure>
	      <title>Destructive looking Shutdown icon</title>
	      <mediaobject><imageobject>
		  <imagedata fileref="images/shutdown-icon.png" format="PNG"/>
		</imageobject>
		<textobject>
		  <phrase>An explosive detonation button</phrase>
		</textobject>
	      </mediaobject>
	    </figure>
	  </para>
	</formalpara>
      </sect2>
    </sect1>
  </chapter>

<chapter id="userinput">
<title>User Input</title>
  <sect1 id="mouse">
    <title>Mouse Interaction</title>
    
    <sect2 id="mouse-buttons">
      <title>Buttons</title>

	<figure> <title>A plethora of pointing devices: mouse, trackball, foot-operated mouse, joystick, trackpad, and a finger-mounted pointing device.</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/pointingdevices.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Pictures of different types of pointing device, including mouse, trackball, foot-operated mouse and joystick.</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      
      <para>For most users, the mouse provides the main way of interacting with graphical user interfaces.  The term &quot;mouse&quot; is used here to include other pointing devices that can be used to move the pointer around the screen, such as trackballs, trackpads, spaceballs, graphics tablets, or assistive technology devices that emulate a mouse.</para>

	
      <para>For right-handed users, the left button on a conventional mouse is used for the majority of mouse actions. We therefore call it the <mousebutton>left button</mousebutton> here, even though it may not always physically be so.  For this reason, you may sometimes see this referred to in code or documentation as &quot;Button 1&quot; or the &quot;Selection Button&quot;.</para>

      <para>Also for right-handed users, the right button on a conventional mouse is the one used for operations involving pop-up menus. We therefore call it the <mousebutton>right button</mousebutton> here, even though it may not always physically be so.  You may sometimes see this referred to in code or documentation as &quot;Button 3&quot; or the &quot;Menu Button&quot;.</para>

      <para>A conventional mouse with three buttons normally has its third button (or a scrollwheel that acts as a button when pushed) between the left and right buttons.  We therefore call it the <mousebutton>middle button</mousebutton>, but you may sometimes see this referred to in code or documentation as &quot;Button 2&quot; or the &quot;Transfer Button&quot;.</para>

	<para>Recommendations:</para>
	<itemizedlist>
	  
	  <listitem><para>The left button should be used for selecting, activating components, dragging, and the display of drop-down menus.</para></listitem>
	  
	  <listitem><para>The right button should be used to display and select actions from a popup menu.</para></listitem>  
	  
	  <listitem><para>The middle mouse button should be used to paste the current PRIMARY (usually the last-highlighted) selection at the pointer position, as follows:</para>
	    
	    <table frame='all'>
	      <title>Effect of modifier keys on a <mousebutton>middle button</mousebutton> transfer operation</title>
	      <tgroup cols='2' align='left'>
		<thead>
		  <row>
		    <entry>Modifier</entry>
		    <entry>Function</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>Unmodified</entry>
		    <entry>Copy selection</entry>
		  </row>
		  <row>
		    <entry><keycap>Ctrl</keycap></entry>
		    <entry>Copy selection</entry>
		  </row>
		  <row>
		    <entry><keycap>Shift</keycap></entry>
		    <entry>Move selection</entry>
		  </row>
		  <row>
		    <entry><keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap></keycombo></entry>
		    <entry>Create link, shortcut or alias to selection</entry>
		</row>

		</tbody>
	      </tgroup>
	    </table>

	<para>Don't over-ride this functionality in any part of your user interface where the transfer action is likely to be useful.  If you do intend to use the middle button for a different purpose somewhere, only do so as a shortcut for experienced users, and only for operations that can also be performed without using the <mousebutton>right button</mousebutton> or <mousebutton>middle button</mousebutton>.</para></listitem>

	<listitem><para>If present, the scrollwheel should scroll the currently focused window or control, if it supports scrolling.  Suggestion for discussion: If it supports both horizontal and vertical scrolling, unmodified scrollwheel should scroll vertically, and <keycombo><keycap>Shift</keycap><mousebutton>scrollwheel</mousebutton></keycombo> <emphasis>(or perhaps <keycombo><keycap>Ctrl</keycap><mousebutton>scrollwheel</mousebutton></keycombo>?)</emphasis> should scroll horizontally.</para></listitem>

	<listitem><para>Don't depend on input from the middle or right mouse buttons. As well as being physically more difficult to click, some pointing devices and many assistive technology devices only support or emulate the left mouse button.  Some assistive technologies may noteven emulate the mouse at all, but generate keyboard events instead.</para></listitem>

	<listitem><para>Ensure that every operation in your application that can be done with the mouse can also be done with the keyboard.  The only exceptions to this are actions where fine motor control is an essential part of the task. For example, controlling movement in some types of action games, or freehand painting in an image-editing application.</para></listitem>

	<listitem><para>Don't warp the mouse pointer, or restrict mouse movement to part of the screen. This can interfere with assistive technologies, and is usually confusing even for users who don't rely on assistive technologies.</para></listitem>

	<listitem><para>Don't require the use of chording (pressing multiple mouse buttons simultaneously) for any operations.</para></listitem>

	<listitem><para>Don't require the use of multiple (triple- or quadruple-) clicking actions for any operations, unless you also provide an accessible alternative method of performing the same action.</para></listitem>

	<listitem><para>Allow all mouse operations to be cancelled. Pressing the Esc key should cancel any mouse operation in progress, such as dragging and dropping a file in a file manager, or drawing a shape in a drawing application.</para></listitem>

	<listitem><para>Actions are not assigned exclusively to the middle button of a three-button mouse: not all mice have one.</para></listitem>

	<listitem><para>Don't make mouse targets too small. In general, any mouse targets you define yourself should be at least as large as the arrow button in a GtkSpinBox in the current gtk theme. Bear in mind that a user with impaired dexterity or vision may be using a theme that results in considerably larger widgets than the default theme.</para></listitem>

	<listitem><para>Don't refer to particular mouse buttons in your interface unless absolutely necessary.  Not everybody will be using a conventional mouse with left, middle and right buttons, so any text or diagrams that refer to those may be confusing.</para></listitem>

      </itemizedlist>
      
    </sect2>

    <sect2 id="selection">
      <title>Selecting Objects</title>
      <sect3>
	<title>Mouse and keyboard equivalents</title>

	<para>For controls or windows that contain a number of objects that the
user can select, either singly or multiply, ensure the following mechanisms are in place to allow selections to be made using either the mouse or the keyboard.</para>
	
	<table frame='all' pgwide='1'>
	  <title>Standard mouse and keyboard selection mechanisms</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry></entry>
		<entry>Mouse</entry>
		<entry>Keyboard</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Select item, deselect all others</entry>
		<entry>Click</entry>
		<entry><keysym>Space</keysym></entry>
	      </row>
	      <row>
		<entry>Add/remove item from selection</entry>
		<entry><keycap>Ctrl</keycap> click (toggles item's selected state)</entry>
		<entry><keycombo><keycap>Ctrl</keycap><keysym>Space</keysym></keycombo> (toggles focused item's selected state)</entry>
	      </row>
	      <row>
		<entry>Extend selection</entry>
		<entry><keycap>Shift</keycap> click</entry>
		<entry><keycombo><keycap>Shift</keycap><keysym>Space</keysym></keycombo>, <keycombo><keycap>Ctrl</keycap><keycap>Home</keycap></keycombo>, <keycombo><keycap>Shift</keycap><keycap>End</keycap></keycombo>, <keycombo><keycap>Shift</keycap><keycap>PageUp</keycap></keycombo>, or <keycombo><keycap>Shift</keycap><keycap>PageDown</keycap></keycombo></entry>
	      </row>
	      <row>
		<entry>Move focus</entry>
		<entry>Click appropriate item to select it</entry>
		<entry>Cursor keys, <keycap>Home</keycap>, <keycap>End</keycap>, <keycap>PageUp</keycap>, and <keycap>PageDown</keycap>. Also moves current selection if container is single-selection only.</entry>
	      </row>
	      <row>
		<entry>Select All</entry>
		<entry>Click first item, then <keycap>Shift</keycap> click last item</entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>A</keycap></keycombo></entry>
	      </row>
	      <row>
		<entry>Deselect All</entry>
		<entry>Click container background</entry>
		<entry><keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>A</keycap></keycombo></entry>
	      </row>
	      <row>
		<entry>Activate selection</entry>
		<entry>Double-click to activate a single selection.  <keycap>Shift</keycap> or <keycap>Ctrl</keycap> double-clicking extends or adds item to selection first before activating the entire selection.</entry>
		<entry><keysym>Return</keysym> activates entire selection.  If nothing is currently selected, selects currently-focused item first.</entry>
	      </row>
	      <row>
		<entry>Invert Selection</entry>
		<entry>No mouse equivalent</entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>I</keycap></keycombo></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect3>

      <sect3>
	<title>Bounding Box Selection</title>

	<para>For a container whose objects may be arranged in two dimensions (e.g. Nautilus "View as Icons"), multiple selection should be possible by dragging a bounding box around one or more objects.  <keycombo action="other" otheraction="drag"><keycap>Shift</keycap><mousebutton>left button</mousebutton></keycombo> <action>drag</action> should add all the objects within the bounding box to the existing selection.  <keycombo action="other" otheraction="drag"><keycap>Ctrl</keycap><mousebutton>left button</mousebutton></keycombo> <action>drag</action> should toggle the selected state of all the objects within the bounding box.</para>
	<para>Recommendations:</para>
	<itemizedlist>

	  <listitem><para>By default, only objects that are completely enclosed by the bounding box when the mouse button is released should be selected.</para></listitem>

	<listitem><para>Always use dynamic highlighting to show which objects are currently selected while the box is being dragged out.  Don't wait until the mouse button is released.  This avoids any uncertainty about which objects will be selected by the bounding box.</para></listitem>

	<listitem><para>When a bounding box is being dragged out within a scrollable window, support automatic scrolling of that window when the box is dragged near the window's edges.</para></listitem>

	</itemizedlist>

	<note>
	  <title>For discussion</title>
	  <para>In practice, if you want to switch between "select completely enclosed objects" and "select partially enclosed objects" mode for bounding box selection in applications where it's useful to do so, you're probably not going to want to do it via the <guilabel>Preferences</guilabel> dialog.  A keyboard modifier while dragging the box, or a GtkCheckMenuItem are more likely to be useful.  Can we think of a standard for either that's worth documenting?</para>
	</note>
	
	<figure> <title>Examples illustrating dynamic selection highlighting during bounding box selection.  In the first example, the folder color and label highlighting changes to indicate selection.  In the second, selection is indicated by the addition of resizing handles to selected objects.</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/rubberband.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Example illustrating dynamic selection highlighting during bounding box selection</phrase>
	    </textobject>
	  </mediaobject>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/rubberband_dia.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Example illustrating dynamic selection highlighting during bounding box selection</phrase>
	    </textobject>
	  </mediaobject>
	  
	</figure>

      </sect3>
    </sect2>

    <sect2 id="drag-drop">
      <title>Drag and Drop</title>

      <para>Drag and drop is a direct manipulation technique. It allows you to perform actions on selected objects by moving them around the screen with the mouse.</para>

      <para>&lt;pics&gt;</para>

      <para>An object is normally dragged by clicking it with the left mouse button, then moving the pointer to the object's target location while the button is still pressed. The object is dropped there by releasing the mouse button.  
<!-- Consensus was not to recommend right-button dragging
Dragging with the right button instead of the left pops up a menu when the button is released, allowing you to choose which action (normally one of Copy, Move, Link or Cancel) to perform.
-->
</para>

      <para>Multiple objects may be dragged by <keycap>Shift</keycap> or <keycap>Ctrl</keycap> selecting them, then dragging any one of the selected objects.</para>
      
      <para>Recommendations:</para>
      <itemizedlist>

	<listitem><para>Provide good visual feedback throughout a drag and drop operation. As the mouse passes over valid targets, highlight them and change the mouse pointer. Use the "no drop" mouse pointer when passing over invalid drop targets.</para></listitem>	<listitem><para>A drag and drop operation can be reversed by using the application's <menuchoice><guimenu>Edit</guimenu><guimenuitem>Undo</guimenuitem></menuchoice> function.</para></listitem>

	<!-- Decided against the right mouse drag
      <listitem><para>Dragging with the right mouse button pops up a menu when the mouse button is released, offering the choice of Copy, Move, Link, and Cancel (or whichever subset of those actions is available).  Cancel should always be available.</para></listitem>
	-->

	<listitem><para>A drag and drop operation can be cancelled by: pressing Esc before releasing the mouse button, by dropping the object back on its original source,

<!-- by dragging withe right mouse button and selecting <guimenu>Cancel</guimenu> on the pop-up menu that appears,--> 

or by dropping the object on an invalid drop target.</para></listitem>

	<listitem><para>Keyboard users can replicate all drag and drop actions using shortcut keys, such as <guimenuitem>Copy</guimenuitem> (<keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>) and <guimenuitem>Paste</guimenuitem> (<keycombo><keycap>Ctrl</keycap><keycap>V</keycap></keycombo>).</para></listitem>

	<listitem><para>Standard pointer shapes are used across all GNOME applications for move, copy, multiple move, multiple copy, and invalid drop target.</para></listitem>
	
	<listitem><para>Valid targets are highlighted as the pointer passes over them.</para></listitem>
	<listitem><para>When an item is being dragged within or into a scrollable window, support automatic scrolling of that window when the mouse is moved near its edges.</para></listitem>

	<!-- Not considered a terribly useful suggestion...
	<listitem><para>A tooltip is provided when the pointer is paused over a valid drop target. It describes what will happen if the object is dropped there.  <emphasis>Is this feasible in GNOME?</emphasis></para></listitem>
	-->
	
	<listitem><para>Attempting to drop multiple objects on a target which can only accept a single object brings up a pop-up menu. From this menu, one of the objects can be selected, or the operation can be cancelled.</para></listitem>

	<listitem><para>In general, dragging a selection within a container should move the selection to the new location, and dragging a selection between containers should copy the selection to the new location.  A "container" may be a boundary imposed by the user interface (e.g. a top-level application window), or a user interface representation of a physical container (e.g. a mail server or disk partition).</para></listitem>

	<listitem><para>By default, dragging is non-destructive, i.e. dragging an object from one container to another drags a link or copy, leaving the original intact.</para></listitem>

	<listitem><para>By default, dropping an object into a different window adds it to the existing contents of that window rather than overwriting them (if both options are available).</para></listitem>
	
      </itemizedlist>

      <note>
	<title>For discussion</title>
	<para>The whole "dragging between containers" thing concerns me, as it's not always obvious to users what constitues a "container", especially when it gets down to physical details that the user may not even know or care about (e.g. different disk partitions). This is why the right mouse drag menu we're now discrediting came into existence in the first place.  There are also exceptions to the rule, e.g. dragging anything into Trash should presumably move it rather than copy it.</para>
      </note>
      
      <para>The default behaviour of a drag and drop operation may be modified by holding the <keycap>Ctrl</keycap> and/or <keycap>Shift</keycap> key throughout.  If the user changes the modifier keys during the drag, e.g. to change a move operation to a copy, change the mouse pointer shape immediately and perform the new action when the mouse button is released.</para>

	<table frame='all'>
	  <title>Effect of modifier keys during a drag and drop operation</title>
	  <tgroup cols='2' align='left'>
	    <thead>
	      <row>
		<entry>Modifier</entry>
		<entry>Function</entry>
	      </row>
	    </thead>
	    <tbody>
	    <row>
	      <entry><keycap>Ctrl</keycap></entry>
	      <entry>Copy</entry>
	    </row>
	    <row>
	      <entry><keycap>Shift</keycap></entry>
	      <entry>Move</entry>
	    </row>
	    <row>
	      <entry><keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap></keycombo></entry>
	      <entry>Create link, shortcut or alias</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

<!-- Booted out for now along with right button drags
      <para>Holding <keycap>Ctrl</keycap>, <keycap>Shift</keycap> or <keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap></keycombo> during a right-button drag has no effect; the same pop-up menu still appears at the drop position.</para>
-->

      <para>Always make drag and drop actions reversible. The application's normal <guimenuitem>Undo</guimenuitem> function (on the <guimenu>Edit</guimenu> menu) should provide for this.  By only allowing objects to be copied between applications, rather than moved, confusion about which application's <guimenuitem>Undo</guimenuitem> function should reverse the action is avoided, as there is only a change in the contents of one window.</para>

	<sect3>
	  <title>Mouse Pointers to Use for Drag and Drop</title>
	  
	  <para>Use the default GTK drag and drop pointers for the standard transfer operations listed below.  This consistency helps ensure the user will know exactly what to expect when they release the mouse button.  If you do have to design a new pointer for a non-standard transfer action not listed here, follow the style of the standard pointers.</para>

	  <table frame='all'>
	    <title>Mouse Pointers for Drag and Drop</title>
	    <tgroup cols='2' align='left'>
	      <thead>
		<row>
		  <entry>Pointer Shape</entry>
		  <entry>Meaning</entry>
		</row>
	      </thead>
	      
	      <tbody>
		<row>
		  <entry>
	            <mediaobject>
		      <imageobject>
			<imagedata fileref="images/dragcursor-move.png" format="PNG"/>
	              </imageobject>
	              <textobject>
		         <phrase>"Move" pointer</phrase>
		       </textobject>
	             </mediaobject>
                  </entry>
		  
		  <entry>Move selection. The dragged selection will be moved to the drop location, removing it from its previous location.</entry>
		</row>
		
		<row>
		  <entry>
                    <mediaobject>
		      <imageobject>
			<imagedata fileref="images/dragcursor-copy.png" format="PNG"/>
	              </imageobject>
	              <textobject>
		         <phrase>"Copy" pointer</phrase>
		       </textobject>
	             </mediaobject>
                  </entry>
		  <entry>Copy selection.  The dragged selection will be copied to the drop location, leaving the original intact.</entry>
		</row>
		<row>
		  <entry>
                    <mediaobject>
		      <imageobject>
			<imagedata fileref="images/dragcursor-link.png" format="PNG"/>
	              </imageobject>
	              <textobject>
		         <phrase>"Link" pointer</phrase>
		       </textobject>
	             </mediaobject>
                  </entry>
		  <entry>Link selection.  A link to the selection will be inserted at the drop location.  How the link appears will be application-dependent, it may be a hyperlink, an icon, or a duplicate of the orignal selection, for example.</entry>
		</row>

<!-- This row omitted if we really don't want right mouse drags
		<row>
		  <entry>
                    <mediaobject>
		      <imageobject>
			<imagedata fileref="images/dragcursor-rmb.png" format="PNG"/>
	              </imageobject>
	              <textobject>
		         <phrase>"Query drop" pointer</phrase>
		       </textobject>
	             </mediaobject>
                   </entry>
		   <entry>Right-mouse drag.  A pop-up menu will be posted at the drop location to ask whether the user wants to Move, Copy, or Link the selection, or Cancel the operation.</entry>
		  </row>
-->
	
		<row>
		  <entry>
                     <mediaobject>
		      <imageobject>
			<imagedata fileref="images/dragcursor-nodrop.png" format="PNG"/>
	              </imageobject>
	              <textobject>
		      <phrase>"Can't drop here" pointer</phrase>
		    </textobject>
	             </mediaobject>
</entry>
		  <entry>Can't drop here.  Show this pointer while the mouse is over an area where the selection cannot be dropped.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>If the user changes modifier keys after a drag has started, for example holding <keycap>Ctrl</keycap> to change the meaning from move to copy, change the mouse pointer shape immediately and respect the new action when the mouse button is released.</para> 

	  <para>You should normally augment the mouse pointer shape with a representation of whatever is being dragged.  This representation should either be kept small or made translucent, so as not to obscure possible drop targets underneath it.</para>

	  <figure>
	    <title>Example of copy pointer augmented by an icon representing the file being copied</title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="images/dragcursor-augmented.png" format="PNG"/>
	      </imageobject>
	      <textobject>
		<phrase>Copy pointer superimposed on icon representing a file being copied, to form a "copy file" pointer</phrase>
	      </textobject>
	    </mediaobject>
	  </figure>
	  
	  <note>
	    <title>For Discussion</title>
	    <para>The pointer shapes shown here aren't actually the current GTK defaults, they're the current KDE (and Windows) defaults.  Should we try and persuade GTK to change?</para>
	  </note>

	</sect3>
	
	<sect3>
	  <title>Mouse Interaction with Applets</title>
	  <para>Sketchy proposal for mouse interaction with Panel Gadgets:</para>
	  <itemizedlist>
	    <listitem><para>Left button: <emphasis>Only</emphasis> the unmodified left button should be used to interact with the gadget's controls. Gadgets should be simple enough not to require modified clicking or clicking with other mouse buttons. (Current offender=deskguide).  Suggestion: Clicking and dragging anywhere within the gadget window whilst holding down the <keycap>Ctrl</keycap> and/or <keycap>Shift</keycap> keys could reposition the gadget as if dragging with the middle mouse button (<keycombo action="other" otheraction="drag"><keycap>Ctrl</keycap><mousebutton>left button</mousebutton></keycombo> <action>drag</action>=copy, if moving to another panel; <keycombo action="other" otheraction="drag"><keycap>Shift</keycap><mousebutton>left button</mousebutton></keycombo> <action>drag</action>=move, if moving to another panel).</para></listitem>
	    
	    <listitem><para>Right button: Clicking the right button <emphasis>anywhere</emphasis> within the gadget's enclosing window should pop-up either the contextual menu for the whole gadget, or the contextual menu for the object within the gadget's window that currently lies under the mouse cursor.</para></listitem>
	    
	    <listitem><para>Middle button: The middle button should be used <emphasis>only</emphasis> for dragging the gadget to a new location.  Clicking and dragging <emphasis>anywhere</emphasis> within the gadget's window should move the gadget; <keycombo action="other" otheraction="drag"><keycap>Ctrl</keycap><mousebutton>left button</mousebutton></keycombo> <action>drag</action> = copy, if moving to another panel; unmodified drag or <keycombo action="other" otheraction="drag"><keycap>Shift</keycap><mousebutton>left button</mousebutton></keycombo> <action>drag</action>=move, if moving to another panel.  (If moving within same panel, I assume we're retaining <keycap>Ctrl</keycap>=switched movement, <keycap>Shift</keycap>=push movement as in 1.4).</para></listitem>
	  </itemizedlist>
	  
	</sect3>
	
      </sect2>
    </sect1>
    
    
    <sect1 id="keyboard">
      <title>Keyboard Interaction</title>
      <sect2 id="keyboard-navigation">
	<title>Keyboard Navigation</title>
	
	<para>A well-designed keyboard user interface plays a key role when you are designing applications. Many power-users prefer to perform most operations with the keyboard rather than the mouse. Visually-impaired users can navigate software more effectively using the keyboard, because using the mouse depends on visual feedback of the mouse pointer location. And mobility impairments can prevent a user from successfully navigating using the mouse, because of the fine motor control skills required.</para>
	
	<para>You should therefore make all mouse actions available from the keyboard, and include keyboard access to all toolbars, menus, links and buttons. Every function your application provides should be available using the keyboard alone. Hide your mouse while you're testing your application if you have to!</para>
	
	
	<figure>
	  <title>Dialog box and menu, with some of their access keys (red) and shortcut keys (blue) highlighted</title>
	  <mediaobject><imageobject>
	      <imagedata fileref="images/mnemonics_and_shortcuts.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Dialog box and menu with access keys and shortcut keys highlighted</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
	
	
	<para>Most functionality is easy to make available from the keyboard, by using access keys and shortcut keys, and the toolkit's built-in keyboard navigation features. All controls with labels should have access keys, and frequently-used menu items should be assigned shortcut keys. However, operations that rely on drag-and-drop, for example, may require more thought to make them keyboard accessible.</para>
	
	<para>Recommendations:</para>
	
	<itemizedlist>
	  
	  <listitem><para>Provide efficient keyboard access to all application features. In particular, ensure every control on menus and in dialog boxes are directly focusable using access keys or shortcut keys.</para></listitem>
	  
	  <listitem><para>Use a logical keyboard navigation order. When navigating around a window with the Tab key, keyboard focus should move between controls in a predictable order.  In Western locales, this is normally left to right and top to bottom.</para></listitem>
	  
	  <listitem><para>Ensure correct tab order for controls whose enabled state is dependent on checkbox, radio button or toggle button state. When such a button is selected, all its dependent controls should be enabled, and all the dependent controls of any other button in the group should be disabled. When the user selects a checkbox, radio button or toggle button that has dependent controls, do not automatically give focus to the first dependent control, but instead leave the focus on the button.  
<!-- See <link linkend="keynav-examples">Keyboard Navigation Examples</link>.--></para></listitem>
	  
	  
	  <listitem><para>Don't over-ride existing system-level accessibility features. For example, <ulink url="http://www.rehab.uiuc.edu/accessx/overview.html">AccessX</ulink> is an X server extension that has been supported since X11R6. The "MouseKeys" feature of this extension allows mouse movement and button clicks to be simulated using the keypad. Therefore you should not add features to your application that can only be accessed by pressing keys on the keypad, as users relying on the MouseKeys feature will not be able to use them.</para></listitem>
	  
	  <listitem><para>Ensure that any text that can be selected with the mouse can also be selected with the keyboard.  This is a convenience for all users, but especially for those for whom fine control of the mouse is difficult.</para></listitem>
	  
	  <listitem><para>Ensure that objects that can be resized or moved by drag and drop can also be resized or moved with the keyboard. For example, icons and windows on the desktop. Where precision sizing and placement is potentially important, e.g. shapes in a diagram, also consider providing a dialog into which you can type co-ordinates, or a means of snapping objects to a user-definable grid.</para></listitem>
	  
	  <listitem><para>Don't use general navigation functions to trigger operations. For example, do not use basic <keycap>Tab</keycap> keyboard navigation in a dialog to activate any actions associated with a control.</para></listitem>
	  
	  <listitem><para>Show keyboard-invoked menus, windows and tooltips near the object they relate to. In GNOME 2.0, users can call up popup menus with <keycombo><keycap>Shift</keycap><keycap>F10</keycap></keycombo>, and tooltips with <keycombo><keycap>Ctrl</keycap><keycap>F1</keycap></keycombo>.  Do not completely hide or obscure the object to which the menu or tooltip refers, however.</para></listitem>
	  
	  <listitem><para>Provide more than one method to perform keyboard tasks where possible. Some users may find some keys and key combinations easier to use than others.</para></listitem>
	  <listitem><para>Don't assign awkward reaches to frequently performed keyboard operations. Some people may only be able to use one hand on the keyboard, so shortcuts that can be easily used with one hand are preferable for common operations.  In any case, having to frequently perform long or difficult reaches on the keyboard can increase muscle strain for all users, increasing the risk of pain or injury.</para></listitem>
	  
	  <listitem><para>Don't require repetitive use of simultaneous keypresses. Some users are only able to press and hold one key at a time. Assistive technologies such as AccessX may allow users to press the keys sequentially rather than simultaneously, but this of course means the operation will take longer for them.</para></listitem>
	</itemizedlist>
	
	<note>
	  <title>For Discussion</title>
	  <para>The point about not having Tab initiate any actions effectively rules out tab completion in dialogs, should we consider/recommend a "hands-free" auto-completion method instead, as offered by OpenOffice, Explorer etc.?  What does our new 2.0 file selection dialog do?</para>
	</note>
	
	
	
	<!-- The following example should "just work" with Owen's patch for radio button keynav, so I'm leaving it out for now.  Are there any other examples we could/should illustrate instead? 
	
      <sect2 id="keynav-examples">
      <title>Keyboard Navigation Examples</title>
	
      <para>The figure below depicts correct <keycap>Tab</keycap> navigation order for a group of three radio buttons, two of which have dependent controls.  (Remember that when the control immediately before the radio button group in this window has focus, pressing Tab will move the  focus either to state 1, 3 or 5 depending on which radio button is already selected).</para>
	
      <example><title>Correct tab order for group of radio buttons with dependent controls</title>
	
      <informaltable frame='all'>
	    
	    <tgroup cols='2'>
	      <tbody>
		<row>
		  <entry>
		    <mediaobject><imageobject>
			<imagedata fileref="images/depend1.png" format="PNG"/>
		  </imageobject>
		    <textobject>
		      <phrase>Group of three radio buttons, first two of which have dependent text field. First radio button has focus.</phrase>
		    </textobject>
		  </mediaobject>
		  </entry>
	  
		  <entry>State 1
		    <itemizedlist>
		      <listitem><para><keycap>Tab</keycap> moves to State 2</para></listitem>
		      <listitem><para><keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves focus to last control before radio button group</para></listitem>
		      <listitem><para><keysym>Down Arrow</keysym> moves to State 3</para></listitem>
		      <listitem><para><keycap>Up Arrow</keycap> beeps and doesn't move focus</para></listitem>
		    </itemizedlist>
		  </entry>
		</row>
	  
		<row>
		  <entry>
		    <mediaobject>
		      <imageobject>
			<imagedata fileref="images/depend1a.png" format="PNG"/>
		  </imageobject>
		    <textobject>
		      <phrase>Group of three radio buttons, first two of which have dependent text field. First radio button's text field has focus.</phrase>
		    </textobject>
		  </mediaobject>
		  </entry>
		  
	  <entry>State 2

	  <itemizedlist>
	      <listitem><para><keycap>Tab</keycap> moves to first control after radio button group</para></listitem>
	    <listitem><para><keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves to State 1</para></listitem>
	  </itemizedlist>

	</entry>		
	</row>
	  
	  <row>
	    <entry>

	  <mediaobject><imageobject>
	      <imagedata fileref="images/depend2.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Group of three radio buttons, first two of which have dependent text field. Second radio button has focus.</phrase>
	    </textobject>
	  </mediaobject>

	</entry>
	  
	  <entry>State 3

	  <itemizedlist>
	    <listitem><para><keycap>Tab</keycap> moves to State 4</para></listitem>
	    <listitem><para><keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves focus to last control before radio button group</para></listitem>
	    <listitem><para><keysym>Down Arrow</keysym> moves to State 5</para></listitem>
	    <listitem><para><keysym>Up Arrow</keysym> moves to State 1</para></listitem>
	  </itemizedlist>

	</entry>
	</row>
	  
	  <row>
	    <entry>

	       <mediaobject>
		  <imageobject>
		     <imagedata fileref="images/depend2a.png" format="PNG"/>
		  </imageobject>
		  <textobject>
		     <phrase>Group of three radio buttons, first two
		     of which have dependent text field. Second radio
		     button's text field has focus.</phrase>
		  </textobject>
	       </mediaobject>

	    </entry>
	    
	    <entry><para>State 4</para><itemizedlist>
		<listitem><para><keycap>Tab</keycap> moves focus to first control after radio button group</para></listitem>
		<listitem><para><keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves to State 3</para></listitem>
	      </itemizedlist></entry>
	    
	  </row>
	  
	  <row>
	    <entry>

	  <mediaobject><imageobject>
	      <imagedata fileref="images/depend3.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Group of three radio buttons, first two of which have dependent text field. Third radio button has focus.</phrase>
	    </textobject>
	  </mediaobject>

	</entry>
	  
	  <entry>State 5

	  <itemizedlist>
	    <listitem><para><keycap>Tab</keycap> moves focus to first control after radio button group</para></listitem>
	    <listitem><para><keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves focus to first control before radio button group</para></listitem>
	    <listitem><para><keysym>Down Arrow</keysym> beeps and doesn't move focus</para></listitem>
	    <listitem><para><keysym>Up Arrow</keysym> moves to State 3</para></listitem>
	  </itemizedlist>

	</entry>
	</row>
	  
	</tbody>
	</tgroup>
	</informaltable>
	</example>
      </sect2>

-->

      <sect3>
	<title>Choosing Access Keys</title>

	<para>All labelled components should have an access key (underlined letter), except toolbar controls, and the <keycap>OK</keycap> and <keycap>Cancel</keycap> buttons in dialogs.</para>



<!-- Consensus was against giving OK and Cancel additional access keys

	<note>
	  <title>For discussion</title>
	  <para>It's been suggested that even OK and Cancel should have access keys, as this is more obvious to newer users.  (KDE does this).  What do we think?  Advantages: means you don't always have to have an Enter-operated default button in dialogs where this might lead you to close the dialog by mistake.  Disadvantages: Adds an extra way for people to do things, potentially adding the "dither" factor; uses up O and C access keys, which could be awkward in larger/tabbed dialogs.</para>
	</note>
-->

	<para>Where possible, access keys should be chosen to be as easy to remember as possible&mdash; normally the first letter of the label should be used.  However, in complex windows, the choice can become more difficult.  Here are some simple rules:</para>

	<orderedlist>
	    <listitem><para>Assign access keys for the most frequently-used controls first.  If it's not clear which controls will be the most frequently used, assign them from left to right, top to bottom (for Western locales).</para></listitem>

	  <listitem><para>Use the first letter of the label, or the first letter in one of the words of a multi-word label, unless another letter provides a better association (e.g. &quot;x&quot; in <guilabel>Exit</guilabel>.)</para></listitem>

	<listitem><para>If the first letter is not available, choose an easy to remember consonant from the label, e.g. &quot;p&quot; in <guilabel>Replace</guilabel>.</para></listitem>

	<listitem><para>If no such consonants are available, choose any available vowel from the label.</para></listitem>
	</orderedlist>

	   <para>If possible, try not to assign access keys to &quot;thin&quot; letters (such as lowercase i or l), or letters with descenders (such as lowercase g or y).  The underlines often don't show up very well on those characters.</para>

	<para>Applications using a non-Roman writing system (such as Kanji) in conjunction with a standard keyboard can have control labels prefixed with alphabetic (Roman) characters as access keys.</para>
	
      </sect3>
      
      <sect3 id="shortcuts">
	<title>Choosing Shortcut Keys</title>

	<para>The tables in this section summarize the standard shortcut keys you should use when your application supports those functions.  Your application won't necessarily support all of these functions&mdash; see <link linkend="standard-menus">Standard Menus</link> for more information.  However, you should use the recommended shortcut keys for those functions you do support.</para> 

	<para>You will probably also want to add your own shortcut keys for functions specific to your application.  If so, as well as following the guidelines below, look at any other existing similar applications to see which shortcut keys they have defined.  Your users may already be using those or similar applications, so being consistent where it is possible and sensible to do so will provide a better user experience for them when they begin to use yours.</para>

	<para>Recommendations:</para>

	<itemizedlist>

	  <listitem><para>Use <keycombo><keycap>Ctrl</keycap><keycap>letter</keycap></keycombo> in preference to other combinations when adding new shortcut keys to your application.</para></listitem>

	  <listitem><para><keycap>Insert</keycap>, <keycap>Delete</keycap>, <keycap>Home</keycap>, <keycap>End</keycap>, <keycap>Page Up</keycap> and <keycap>Page Down</keycap> are acceptable shortcut keys for functions that are closely related to those keys' normal system-defined uses.  Don't assign them to unrelated functions just because you've run out of other shortcut key combinations.</para></listitem>

	  <listitem><para>Only assign shortcut keys to the most commonly-used actions in your application.  Don't try to assign a shortcut key to everything.</para></listitem>

	  <listitem><para>Choose new shortcut keys to be as mnemonic as possible, as they are easier to learn and remember.  For example, <keycombo><keycap>Ctrl</keycap><keycap>E</keycap></keycombo> would be a good shortcut for a menu item called <guimenuitem>Edit Page</guimenuitem>.</para></listitem>

	  <listitem><para>Use <keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>letter</keycap></keycombo> for functions that reverse or extend another function.  For example, <keycombo><keycap>Ctrl</keycap><keycap>A</keycap></keycombo> and <keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>A</keycap></keycombo> for <guimenuitem>Select All</guimenuitem> and <guimenuitem>Deselect All</guimenuitem>, and <keycombo><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo> and <keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo> for <guimenuitem>Undo</guimenuitem> and <guimenuitem>Redo</guimenuitem>.</para></listitem>
	  
	  <listitem><para>Don't use <keycombo><keycap>Ctrl</keycap><keycap>number</keycap></keycombo> or numbered function keys as shortcut keys, unless the number has some obvious relevance to the action.  For example, <keycombo><keycap>Ctrl</keycap><keycap>2</keycap></keycombo> and <keycombo><keycap>Ctrl</keycap><keycap>3</keycap></keycombo> may be acceptable shortcut keys for <menuchoice><guimenu>View</guimenu><guimenuitem>2D View</guimenuitem></menuchoice> and <menuchoice><guimenu>View</guimenu><guimenuitem>3D View</guimenuitem></menuchoice> in a 3D modelling application.</para></listitem>
	  	  
	  <listitem><para>Don't use <keycombo><keycap>Alt</keycap><keycap>key</keycap></keycombo> combinations for shortcut keys, as these may conflict with menu access keys.</para></listitem>

	  <listitem><para>Don't use symbols that require <keycap>Shift</keycap> or other modifiers as part of a shortcut, for example <keycombo><keycap>Ctrl</keycap><keycap>%</keycap></keycombo>.  Remember that symbols that can be accessed without a modifier key on your keyboard may be more difficult to access on different international keyboards.</para></listitem>
	  
	  <listitem><para>Don't assign shortcut keys to menu items that change over time, for example a list of open windows on the <guimenu>Window</guimenu> menu, or a recently-used file list on the <guimenu>File</guimenu> menu.</para></listitem>
	  
	  <listitem><para>Don't use any of the standard shortcut keys listed here for your own purposes,  even if your application doesn't support those functions.  This will help reinforce consistency between GNOME applications.</para></listitem>

	</itemizedlist>

	<table frame='all' pgwide='1'>
	  <title>Standard GNOME application shortcut keys and access keys - File menu</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Shortcut</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><guimenuitem><accel>N</accel>ew</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>N</keycap></keycombo></entry>
		<entry>Create a new document</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>O</accel>pen</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>O</keycap></keycombo></entry>
		<entry>Open a document</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>S</accel>ave</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>S</keycap></keycombo></entry>
		<entry>Save the current document</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>P</accel>rint</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>P</keycap></keycombo></entry>
		<entry>Print the current document</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>C</accel>lose</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>W</keycap></keycombo></entry>
		<entry>Close the current document</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>Q</accel>uit</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>Q</keycap></keycombo></entry>
		<entry>Quit the application</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<table frame='all' pgwide='1'>
	  <title>Standard GNOME application shortcut keys and access keys - Edit menu</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Shortcut</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><guimenuitem><accel>U</accel>ndo</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo></entry>
		<entry>Undo the last operation</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>R</accel>edo</guimenuitem></entry>
		<entry><keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo></entry>
		<entry>Redo the last operation</entry>
	      </row>
	      <row>
		<entry><guimenuitem>Cu<accel>t</accel></guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>X</keycap></keycombo></entry>
		<entry>Cut the selected area and store it in the clipboard</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>C</accel>opy</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo></entry>
		<entry>Copy the selected area into the clipboard</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>P</accel>aste</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>V</keycap></keycombo></entry>
		<entry>Paste contents of clipboard at mouse/cursor position</entry>
	      </row>
	      <row>
		<entry><guimenuitem>Select <accel>A</accel>ll</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>A</keycap></keycombo></entry>
		<entry>Select everything in focused control or window</entry>
	      </row>

	      <row>
		<entry><guimenuitem>Deselect All</guimenuitem></entry>
		<entry><keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>A</keycap></keycombo></entry>
		<entry>Deselect everything in focused control or window</entry>
	      </row>
	      <row>
		<entry><guimenuitem>In<accel>v</accel>ert Selection</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>I</keycap></keycombo></entry>
		<entry>Select everything in focused control or window that was previously unselected, and deselect everything that was previously selected</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>D</accel>elete</guimenuitem></entry>
		<entry><keycap>Del</keycap></entry>
		<entry>Delete selection</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>F</accel>ind</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>F</keycap></keycombo></entry>
		<entry>Find</entry>
	      </row>
	      <row>
		<entry><guimenuitem>Find Ne<accel>x</accel>t</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>G</keycap></keycombo></entry>
		<entry>Find the next match</entry>
	      </row>
<!-- Replace may go depending on response to mpt's comment that Replace should be part of standard Find dialog functionality-->
	      <row>
		<entry><guimenuitem><accel>R</accel>eplace</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>R</keycap></keycombo></entry>
		<entry>Find and replace matches</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>


	<note><title>For discussion</title>

<!-- Consensus was for "Deselect All"
	  <para>czr currently proposing "Select None" rather than "Deselect All", which is better?  I prefer the latter because it's more visually distinct on a menu, in English at least.</para>
-->
<!-- Um, consensus was to be rid of the item, iirc. (GJM) -->
	  <para>Should we call it "Find Next" or "Find Again"?</para>

	  <para>czr currently proposing Ctrl+R for "Replace", but this clashes with "Reload" in most browser applications&mdash; not a problem until somebody writes a graphical HTML editor that you can also do search/replace in :o)  Ctrl+H is another common shortcut for "Replace", should we use this instead?  (It's not as easy to access with one hand, though, so maybe not).</para>

	  <para>mpt suggesting that Replace should be part of Find dialog, so shortcut for Replace may not be required at all.</para>

<!-- Consensus is to keep Letter-based shortcut keys
	  <para>Kenneth suggests a more F-key-based system, e.g. F5 for Refresh rather than Ctrl+R, as "Ctrl+R" is only memorable if you happen to speak English... what's our view on this?</para>
-->

	</note>

	
	

	<table frame='all' pgwide='1'>
	  <title>Standard GNOME application shortcut keys and access keys - View menu</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Shortcut</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><guimenuitem>Zoom <accel>I</accel>n</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keysym>Plus</keysym></keycombo></entry>
		<entry>Zoom in on the document</entry>
	      </row>
	      <row>
		<entry><guimenuitem>Zoom <accel>O</accel>ut</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keysym>Minus</keysym></keycombo></entry>
		<entry>Zoom out of the document</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>R</accel>eload</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>R</keycap></keycombo></entry>
		<entry>Redraw/reload the current document</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<note><title>Reload/Refresh</title>
	  <para>Some applications need both reload and refresh, should we specify shortcut keys for both? (E.g. <keycombo><keycap>Ctrl</keycap><keycap>R</keycap></keycombo> = refresh, <keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>R</keycap></keycombo> = reload, or vice versa?)</para>
	</note>
	
	<table frame='all' pgwide='1'>
	  <title>Standard GNOME application shortcut keys and access keys - Bookmarks menu</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Shortcut</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><guimenuitem>Add <accel>B</accel>ookmark</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>D</keycap></keycombo></entry>
		<entry>Add a bookmark for the current location</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>E</accel>dit Bookmarks...</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>B</keycap></keycombo></entry>
		<entry>Open a window in which the user can edit and organise saved bookmarks</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	
	<table frame='all' pgwide='1'>
	  <title>Standard GNOME application shortcut keys and access keys - Format menu</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Shortcut</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><guimenuitem><accel>B</accel>old</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>B</keycap></keycombo></entry>
		<entry>Make selected text bold/regular</entry>
		</row>
	      <row>
		<entry><guimenuitem><accel>U</accel>nderline</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>U</keycap></keycombo></entry>
		<entry>Underline/remove underline from selected text</entry>
	      </row>
	      <row>
		<entry><guimenuitem><accel>I</accel>talic</guimenuitem></entry>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>I</keycap></keycombo></entry>
		<entry>Make selected text italic/regular</entry>
	      </row>  
	    </tbody>
	  </tgroup>
	</table>

	<note><title>For discussion</title>
	  <para>Is it acceptable to specify the same shortcut for <menuchoice><guimenu>Format</guimenu><guimenuitem>Bold</guimenuitem></menuchoice> and <menuchoice><guimenu>Bookmarks</guimenu><guimenuitem>Edit Bookmarks</guimenuitem></menuchoice>, given that the two aren't likely to occur in the same application?  Or could/should we provide a second choice for one of them on the off-chance that they do coincide?</para>
	</note>

	<table frame='all' pgwide='1'>
	  <title>Standard GNOME application shortcut keys and access keys - Help menu</title>
	  <tgroup cols='3' align='left'>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Shortcut</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><guimenuitem>Help</guimenuitem></entry>
		<entry><keycap>F1</keycap></entry>
		<entry>Obtain help and documentation for the application</entry>
	      </row>
	      <row>
		<entry><guimenuitem>Context Help</guimenuitem></entry>
		<entry><keycombo><keycap>Shift</keycap><keycap>F1</keycap></keycombo></entry>
		<entry>Obtain help and documentation for the currently focused control or window</entry>
	      </row>
	
	    </tbody>
	  </tgroup>
	</table>

	<note>
	  <title>For Discussion</title>
	  <para>Greg suggested Ctrl+H for Search Help... this doesn't seem to me to be an important enough function to tie up Ctrl+H with, though, anyone got any other views/alternative suggestions?</para>
	</note>
	  
      </sect3>

      <sect3>
	<title>Standard Widget Navigation Shortcut Keys</title>
	<para>The following shortcut keys are reserved for keyboard navigation use by the various widgets used in GNOME, and should not normally be over-ridden by your application.</para>

	<table frame='all' pgwide='1'>
	  <title>Standard GNOME keyboard navigation keys for widgets</title>
	  <tgroup cols='2' align='left'>
	    <thead>
	      <row>
		<entry>Key</entry>
		<entry>Function</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><keycap>Tab</keycap>, <keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo></entry>
		<entry>Moves keyboard focus to next/previous control</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>Tab</keycap></keycombo>, <keycombo><keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>Tab</keycap></keycombo></entry>
		<entry>Moves keyboard focus out of enclosing widget to next/previous control, in those situations where Tab alone has another function (e.g. GtkTextView)</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>F1</keycap></keycombo></entry>
		<entry>Pop up tooltip for currently-focused control</entry>
	      </row>
	      <row>
		<entry><keycap>F6</keycap>, <keycombo><keycap>Shift</keycap><keycap>F6</keycap></keycombo></entry>
		<entry>Give focus to next/previous pane in a GtkPaned window</entry>
	      </row>
	      <row>
		<entry><keycap>F8</keycap></entry>
		<entry>Give focus to splitter bar in paned window</entry>
	      </row>
	      <row>
		<entry><keycap>F10</keycap></entry>
		<entry>Give focus to window's menu bar</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Shift</keycap><keycap>F10</keycap></keycombo></entry>
		<entry>Pop up contextual menu for currently-selected objects</entry>
	      </row>
	      <row>
		<entry><keysym>Space</keysym></entry>
		<entry>Toggle selected state of focused checkbox, radio button, or toggle button</entry>
	      </row>
	      <row>
		<entry><keysym>Return</keysym></entry>
		<entry>Activate focused button, menu item etc.</entry>
	      </row>
	      <row>
		<entry><keycap>Home</keycap>, <keycap>End</keycap></entry>
		<entry>Select/move to first item in selected widget</entry>
	      </row>
	      <row>
		<entry><keycap>PageUp</keycap>, <keycombo><keycap>Ctrl</keycap><keycap>PageUp</keycap></keycombo>, <keycap>PageDown</keycap>, <keycombo><keycap>Ctrl</keycap><keycap>PageDown</keycap></keycombo></entry>
		<entry>Scroll selected view by one page up/right/down/left</entry>
	      </row>
 	      </tbody>
	  </tgroup>
	</table>
	     
      </sect3>
      
      <sect3>
	<title>Additional Widget Navigation Shortcut Keys</title>

	<para>The following emacs-style navigation shortcut keys may still be available in GNOME 2.0 text entry fields, but disabled by default.  Since some users may still wish to use them, you should not over-ride them for your own purposes in any situations where a text entry control has focus.</para>

	<table frame='all' pgwide='1'>
	  <title>Emacs-style navigation keys for widgets</title>
	  <tgroup cols='2' align='left'>
	    <thead>
	      <row>
		<entry>Key</entry>
		<entry>Function</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>A</keycap></keycombo></entry>
		<entry>Move cursor to beginning of line</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>D</keycap></keycombo></entry>
		<entry>Delete character following/under cursor</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>E</keycap></keycombo></entry>
		<entry>Move cursor to end of line</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>K</keycap></keycombo></entry>
		<entry>Delete from cursor to end of line</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>U</keycap></keycombo></entry>
		<entry>Delete current line</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>W</keycap></keycombo></entry>
		<entry>Cut to clipboard</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>Y</keycap></keycombo></entry>
		<entry>Paste from clipboard</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keysym>Space</keysym></keycombo></entry>
		<entry>Set mark</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keycap>Del</keycap></keycombo>, <keycombo><keycap>Alt</keycap><keycap>D</keycap></keycombo></entry>
		<entry>Delete from cursor to end of word</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Ctrl</keycap><keysym>Backspace</keysym></keycombo></entry>
		<entry>Delete from cursor to start of word</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Alt</keycap><keysym>Space</keysym></keycombo></entry>
		<entry>Delete all whitespace around cursor, reinsert single space</entry>
	      </row>
	      <row>
		<entry><keycombo><keycap>Alt</keycap><keycap>\</keycap></keycombo></entry>
		<entry>Delete all whitespace around cursor</entry>
	      </row>
	      </tbody>
	  </tgroup>
	</table>
	
      </sect3>

    </sect2>


  </sect1>
  </chapter>
<!-- disabled for the draft, we can re-enable when content gets written -seth
  <chapter id="language">
    <title>Language</title>
    <para>FIXME</para>
  </chapter>
-->
<!-- we can change the title as soon as the content is written
     I want the document to be as usable and correct as possible
     this week -seth

  <chapter id="checklists">
    <title>Checklists</title>
-->

  <chapter id="reality-checks">
    <title>Checklists</title>
    <sect1>
      <title>Things You Can Do Yourself</title>
      <sect2>
	<title>Before You Start</title>

	<para>Write down the type of people you expect to use your application.  Then write some &quot;scenarios&quot; for each type of user&mdash; a little story that describes the typical tasks those users will use your application for.  These tasks should be along the lines of:</para>

	<blockquote><para>Fred needs to find an email about widgets that he received last week</para></blockquote>

	<para>rather than </para>

	<blockquote><para>Fred clicks on the <guibutton>Find</guibutton> button and types <userinput>widgets</userinput> into the dialog.</para></blockquote>

	<para>This way, you can use the same scenarios to test and compare different GUI designs, and to spot any missing functionality.</para>

	<para>Include these user descriptions and scenarios with the documentation you commit to CVS.  This way, other contributors will get to understand your users too, can help to develop the application with that knowledge, and can provide more scenarios of their own.</para>
      </sect2>
      
      <sect2>
	<title> Keyboard Access and Focus</title>

	<para>When you have started implementing your GUI, hide your mouse, and make sure you can still use it to do everything using only the keyboard. Implement keyboard functionality at the same time as mouse functionality&mdash; don't leave it until the end.</para>

	<para>Using only keyboard commands, move the focus through all menu bars and toolbars in the application. Also confirm that:</para>
	
	<itemizedlist>
	  <listitem><para>Context sensitive menus display correctly (<keycombo><keycap>Shift</keycap><keycap>F10</keycap></keycombo>).</para></listitem>
	  <listitem><para>Tooltips can be popped up and down for all controls that have them (<keycombo><keycap>Ctrl</keycap><keycap>F1</keycap></keycombo>, <keycap>Esc</keycap>).</para></listitem>

	  <listitem><para>All functions listed on the toolbar can be performed using the keyboard.</para></listitem>

	  <listitem><para>You can fully operate every control in the client area of the application and dialog boxes.</para></listitem>

	  <listitem><para>Text and objects within the client area can be selected.</para></listitem>

	  <listitem><para>Any keyboard enhancements or shortcut keys are working as designed.</para></listitem>

	  <listitem><para>Verify that when moving among objects, the visual focus indicator is easy to identify at all times.</para></listitem>
	</itemizedlist>
	
      </sect2>
      
      <sect2>
	<title>Theming, Colors and Contrast</title>

	<para>Test various GNOME themes to ensure that your application respects all the available settings.</para>

	<para>Test your application with black and white, high contrast themes and confirm that all information is still conveyed correctly.  If you don't have a suitable high contrast GNOME theme available to test, print off some screenshots in black and white (not greyscale) and make sure all the important information is still visible&mdash; this will approximate what a high contrast theme user will see.</para>
      </sect2>

      <sect2>
	<title>Animation</title>

	<para>Ensure you have implemented an option to turn off any animation in your application (for accessibility reasons), and that it is working as designed.  Turn the animation off. Confirm that all information is still conveyed correctly.</para>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Things You Can Do With Other People</title>
      <sect2>
	<title>Get Early Feedback</title>
	
	<para>It's always tempting, but don't start coding your GUI straight away.  Sketch out some ideas on paper first, or in Glade or HTML if you prefer.  (But don't be tempted add any functionality at this point if you do it this way!)</para>

	<para>Show these prototypes to other people&mdash; the GNOME mailing lists and IRC are ideal for finding likely candidates.  Ask them to use these prototype GUIs to run through some of the scenarios you came up with earlier.  You'll probably get questions like "how would I do X", "which menu is Y on"... these questions will help you think about the GUI from the user's viewpoint.  You'll probably also get a few suggestions about how to do things differently&mdash; these ideas may or may not turn out to better than yours, but any idea from a potential user is worth considering!</para>

	<para>You should also consider seeking opinions from the <ulink url="http://developer.gnome.org/projects/gup/">GNOME Usability team</ulink>.  They have designed many user interfaces before and may be able to spot potential problems at this early stage, before you take your design too far to change easily.</para>

	<para>Once you've decided on the basic GUI design and have started coding parts of it, find somebody to try it out again&mdash; it doesn't have to be the same person.  You'll probably find some more problems that were hard to see on your static paper prototype.  By finding these now, it's usually not too late to fix them without too much trouble.</para>
      </sect2>
      
      
      <sect2>
	<title>Internationalization and Localization</title>

	<para>If you intend your application to be translated into different languages, show draft designs of your application to the <ulink url="http://developer.gnome.org/projects/gtp/contact.html">GNOME Translation Team</ulink>.  They'll help you find potential translation problems, such as not leaving enough space for translated labels, shortcut keys that cause problems on a different keyboard layout, or using new terms in your app that are hard to translate.</para>

	<para>If possible, try out your application with users from the locales you are targeting.  This will help you determine whether users understand how to use the application, if they perceive the graphics and colors the way you intended, and if there are words or images in the application that may cause offence to users of that locale. </para>
      </sect2>

    </sect1>
  </chapter>

  <chapter id="credit">
    <title>Credit</title>

    <sect1 id="authors">
      <title>Authors</title>
      <!-- FIXME: need e-mail addresses -->
      <para>
	<itemizedlist>
	  <listitem><para>Calum Benson</para></listitem>
	  <listitem><para>Adam Elman</para></listitem>
	  <listitem><para>Gregory Merchan</para></listitem>
	  <listitem><para>Seth Nickell</para></listitem>
	  <listitem><para>Colin Z. Robertson</para></listitem>
	  <listitem><para>Maciej Stachowiak</para></listitem>
	</itemizedlist>
      </para>
    </sect1>

    <sect1>
      <title>Reviewers & Contributors</title>

      <para>
	<itemizedlist>
	  <listitem><para>Kathy Fernandes</para></listitem>
	  <listitem><para>John Fleck</para></listitem>
	  <listitem><para>Andrea Mankoski</para></listitem>
	  <listitem><para>Nils Pederson</para></listitem>
	  <listitem><para>Christian Rose</para></listitem>
	  <listitem><para>Sharon Snider</para></listitem>
	  <listitem><para>Suzanna Smith</para></listitem>
	  <listitem><para>Matthew Thomas</para></listitem>
	</itemizedlist>
      </para>
<!--
      <authorgroup>
      <author><firstname>Calum</firstname>  <surname>Benson</surname><affiliation><address><email>calum.benson@sun.com</email></address></affiliation></author>
      <author><firstname>Adam</firstname><surname>Elman</surname><affiliation><address><email>aelman@users.sourceforge.net</email></address></affiliation></author>
<author><firstname>Gregory</firstname><surname>Merchan</surname><affiliation><address><email>merchan@phys.lsu.edu</email></address></affiliation></author>
<author><firstname>Seth</firstname><surname>Nickell</surname><affiliation><address><email>snickell@stanford.edu</email></address></affiliation></author>
<author><firstname>colin</firstname><othername role="mi">z</othername><surname>robertson</surname><affiliation><address><email>czr@rtnl.org.uk</email></address></affiliation></author>
</authorgroup>
-->
</sect1>
</chapter>
</book>
