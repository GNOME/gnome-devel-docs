<!DOCTYPE ARTICLE PUBLIC "-//GNOME//DTD DocBook PNG Variant V1.1//EN" [
<!ENTITY version "0.0.1"> <!-- Do we have a versioning policy? -->
]>

<article id="index">

<artheader>

<authorgroup>

<author>
  <firstname>Calum</firstname>
  <surname>Benson</surname>
  <affiliation>
    <address>
      <email>calum.benson@sun.com</email>
    </address>
  </affiliation>
</author>

<author>
  <firstname>Adam</firstname>
  <surname>Elman</surname>
  <affiliation>
    <address>
      <email>aelman@users.sourceforge.net</email>
    </address>
  </affiliation>
</author>

<author>
  <firstname>Gregory</firstname>
  <surname>Merchan</surname>
  <affiliation>
    <address>
      <email>merchan@phys.lsu.edu</email>
    </address>
  </affiliation>
</author>

<author>
  <firstname>colin</firstname>
  <othername role="mi">z</othername>
  <surname>robertson</surname>
  <affiliation>
    <address>
      <email>czr@rtnl.org.uk</email>
    </address>
  </affiliation>
</author>

</authorgroup>

<releaseinfo>
  This is a pre-release!
</releaseinfo>
    
<revhistory>
<revision>
<revnumber>0.0.1</revnumber>
<date>2001-09-05</date>
</revision>
<revision>
<revnumber>0.0</revnumber>
<date>2001-08-11</date>
</revision>
</revhistory>
    
<copyright>
<year>2001</year>
<holder>Calum Benson, Adam Elman, Gregory Merchan, colin z robertson</holder>
</copyright>

<legalnotice>
  <para>
      Permission is granted to copy, distribute and/or modify this
      document under the terms of the <citetitle>GNU Free Documentation
      License</citetitle>, Version 1.1 or any later version published
      by the Free Software Foundation with no Invariant Sections, no
      Front-Cover Texts, and no Back-Cover Texts. You may obtain a copy
      of the <citetitle>GNU Free Documentation License</citetitle> from
      the Free Software Foundation by visiting <ulink type="http"
      url="http://www.fsf.org">their Web site</ulink> or by writing to:
      Free Software Foundation, Inc., 59 Temple Place - Suite 330,
      Boston, MA 02111-1307, USA.
  </para>
  <para>
      Many of the names used by companies to distinguish their products and
      services are claimed as trademarks. Where those names appear in any
      GNOME documentation, and those trademarks are made aware to the members
      of the GNOME Documentation Project, the names have been printed in caps
      or initial caps.
  </para>
</legalnotice>

<!-- FIXME: Someone think of a better title. HI Handbook, perhaps? -->
<title>The GNOME 2.0 Mini Human Interface Guidelines</title>

</artheader>
  
<sect1 id="intro">
  
<title>Introduction</title>

<sect2 id="why-we-care">
	
<title>Why we care about usability (and so should you)</title>

</sect2>

</sect1>
  
<sect1 id="usability-principle">
  
<title>Usability Principles</title>

</sect1>

<sect1 id="menus-and-toolbars">
  
<title>Menus and Toolbars</title>
	
<sect2 id="menu-principles">

<!-- TODO:
- Tear-off menus?
- Menu bar position
- Menu bar hiding
- When should there be a menu bar?
-->

<title>Menu Principles</title>

<para>
Menus are a means by which a set of commands can be made available to the user, allowing the user to make a choice, and removing the need to memorise the command set.
</para>

<sect3 id="menu-principles-drop-down">

<title>Drop-Down Menus</title> <!-- "Pull-down" menus? -->

<para>
Applications may possess a menubar providing a number of drop-down menus. This menubar will be visible at all times and will always be accessible via the keyboard as well as the mouse, and for this reason it should give access to all commands available in the application.
</para>

</sect3>

<sect3 id="menu-principles-context">

<title>Popup menus</title>

<para>
Clicking on an object with the right mouse button may display a popup menu which should contain commands which can be applied to the selected object. (The act of clicking may change the selection.) Since popup menus are not accessible via the keyboard and since the user may not be aware of their presence, any items they contain should also be available via the application's menubar.
</para>

</sect3>

<sect3 id="menu-principles-organisation">

<title>Menu Organisation</title>

<para>
It should be easy for a user to find the command they need in the menu hierarchy. Menus should contain only items which are related to the title of the menu. Menus and menu items should not appear or disappear while the application is running.
</para>

<sect4 id="menu-principles-submenus">

<title>Submenus</title>

<para>
Submenus may be used to add a further level of hierarchy to a menu and to save space in an interface. Submenus should be used sparingly, since they are physically difficult to navigate and they make it harder to find the items they contain.
</para>

</sect4>

<sect4 id="menu-principles-separators">

<title>Separators</title>

<para>
Related items should be grouped together on a menu and should be separated from other groups using separators. This creates a set of visual <quote>landmarks</quote> and makes it easier for the user to quickly scan a menu for the item they are interested in.
</para>

</sect4>

</sect3>

<sect3 id="menu-principles-naming">

<title>Naming Conventions</title>

<para>
Most menu items will be labelled with verbs or adjectives, which describe commands or properties respectively. Menu items should have the first letter of the first word and of any significant words capitalised.
</para>

<para>
Where a command requires further input from the user before it can be performed, it should be marked with an ellipsis ("..."). However, items should not be given an ellipsis to indicate only that a confirmation dialog will be presented or that the result of a command will be that a dialog is presented to the user.
</para>

</sect3>

<sect3 id="menu-principles-unavailable">

<title>Unavailable Items</title>

<para>
Menu items should be made unavailable at any time at which they cannot be used. For example, the <menuchoice><guimenu>Edit</guimenu> <guimenuitem>Copy</guimenuitem></menuchoice> command, which relies on there being some data selected in the application, should be unavailable at any point at which no data is selected.
</para>

<para>
Items should not be removed from the menu when they are unavailable. Instead, they are presented in dimmed lettering. This allows the user to see what commands might be available at other times and prevents menu items from shifting positions.
</para>

</sect3>

<sect3 id="menu-principles-toggled">

<title>Toggled menu items</title>

<para>
Menu items may be toggled between two states. This may be done either independently in the same way as check boxes or as part of a group as with radio buttons.
</para>

<para>
Any group of items operating in the same manner as a group of radio buttons should appear on their own in a menu or submenu or be separated from other items in the menu by using separators.
</para>

</sect3>

<sect3 id="menu-principles-shortcuts-accelerators">

<title>Shortcuts and accelerators</title>

<para>
As with other controls, all menu items should have an accelerator key associated with them. Unlike other controls, once a menu is visible, its accelerators are accessible just by typing the letter; it is not necessary to press the Alt key at the same time.
</para>

<para>
Developers may assign keyboard shortcuts to menu items. It is not necessary to assign shortcuts to every item -- just those which will be frequently used.
</para>

<para>
Shortcuts should consist of the Ctrl key and an alphanumeric key, or of one of the keys F1-F12, Insert, Delete, Home, End, Page Up or Page Down. The Shift key may be used as an additional modifier for commands which are related to or the opposite of the command accessed without the Shift key.
</para>

</sect3>

</sect2>

<sect2 id="standard-menus">
	
<title>Standard Menus</title>

<para>
There are a number of standard drop-down menus for common operations. The menus on a menubar should be placed in the following order: File, Edit, <replaceable>application-specific menus</replaceable>, Options, Help. (Help should be the rightmost menu, but it should not be flush-right.)
</para>

<sect3 id="menu-standard-file">

<title>File</title>

<para>
<literallayout class="monospaced">_File
    _New                Ctrl-N
    _Open...            Ctrl-O
    Open _Recent        >
    ---
    _Save               Ctrl-S
    Save _As...
    Re_vert to Saved
    _Close <replaceable>docname</replaceable>      Ctrl-W
    ---
    _Print              Ctrl-P
    Print Preview...
    Print Setup...
    ---
    Close All
    _Quit <replaceable>appname</replaceable>       Ctrl-Q</literallayout>
</para>

<para>
All applications should have a <guimenu>File</guimenu> menu which should contain items relating to creating, opening, saving, closing and printing documents and for exiting the application.
</para>

<para>
Applications which do not obviously operate on files may rename this menu to something more appropriate. For example, games may have a <quote>Game</quote> menu instead of a <quote>File</quote> menu.
</para>

<sect4>

<title>File Access</title>

<para>
On document-editing applications, the items <guimenuitem>New</guimenuitem>, <guimenuitem>Open</guimenuitem>, <guimenuitem>Save</guimenuitem>, <guimenuitem>Save As</guimenuitem> and <guimenuitem>Close</guimenuitem> must be present, <guimenuitem>Revert</guimenuitem> should be present, and <guisubmenu>Open Recent</guisubmenu> may be present.
</para>

<variablelist>

<varlistentry>
<term>New</term>
<listitem>
<para>
Creates a new document. The <guimenuitem>New</guimenuitem> command should create a new window or tab (depending on the users MDI settings) with a blank document in it. <!-- FIXME: titling, -->
</para>
<para>
Where the application may create a number of different types of document, the <guimenuitem>New</guimenuitem> item may be a submenu containing entries for these various types. These entries should be labelled <quote>New <replaceable>document type</replaceable></quote> and the most commonly used item should be the first entry in the submenu and should be given the Ctrl-N shortcut.
</para>
<para>
A blank document will not necessarily be truly blank. For example, a document created from a template may already contain some data.<!-- FIXME: More on templates -->
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Open</term>
<listitem>
<para>
Opens an existing document. The user should be presented with a standard file open dialog from which they may choose an existing file. If the user's choice is already open in that application then the user should be notified via a dialog that the file is already open and the window containing that file should be given the focus and raised. If the current window contains a blank untitled document then it should be replaced with the selected file. Otherwise the file should be opened in a new window.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Open Recent</term>
<listitem>
<para>
Allows the user to open a recently used file. The application should maintain a history of recently opened documents and these should be accessible via a submenu. Selecting one of these files should open that file in the same way that <guimenuitem>Open</guimenuitem> does.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Save</term>
<listitem>
<para>
Saves the document to its current filename. If the document has a filename associated with it then the document should be saved to that file without any further interaction with the user. If there are any additional options involved in saving a file (eg. DOS or UNIX-style line endings in a text file) then these should remain as they were the last time the document was saved. If the document has no associated filename then the action should be the same as that of <guimenuitem>Save As</guimenuitem>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Save As</term>
<listitem>
<para>
Saves the document to a new filename. The <guimenuitem>Save As</guimenuitem> command should present the user with a standard file save as dialog and save the file with the chosen file name. <!-- FIXME: errors, additional information-->
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Revert</term>
<listitem>
<para>
Reverts the document to the last saved state. The user should be presented with with a warning that all changes will be lost and given the option of cancelling before reloading the file.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Close <replaceable>docname</replaceable></term>
<listitem>
<para>
Close the current document. If the document in the current window has unsaved changes then the user should be presented with a dialog giving the option to save changes (which should function like the <menuchoice><guimenu>File</guimenu> <guimenuitem>Save</guimenuitem></menuchoice> command), discard the changes or cancel the action. If the window being closed is the last open document of that application then the application should, in the case of an SDI interface, leave the user with a blank document, or, in the case of a controlled SDI interface, the control window should be left open. The label of the <guimenuitem>Close</guimenuitem> item should include the name of the current document.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

<sect4>

<title>Printing</title>

<variablelist>

<varlistentry>
<term>Print</term>
<listitem>
<para>
Prints the current document. The <guimenuitem>Print</guimenuitem> command should brings up a print dialog allowing the user to set such options as the page range to be printed, the printer to be used, and so on. The dialog should contain a button marked <quote>Print</quote> which should start the actual printing and close the dialog.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Print Preview</term>
<listitem>
<para>
Shows the user what the printed document will look like. The <guimenuitem>Print Preview</guimenuitem> command should bring up a new window containing an accruate represenation of the appearance of the document as it would be printed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Print Setup</term>
<listitem>
<para>
Allows the user to control print-related settings. The user should be presented with a dialog allowing the user to set such options as portrait or landscape format, margins, and so on.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

<sect4>

<title>Quitting</title>

<para>
All Applications must have a <guimenuitem>Quit</guimenuitem> item. Applications which are capable of editing multiple documents simultaneously should have a <guimenuitem>Close All</guimenuitem> item.
</para>

<variablelist>

<varlistentry>
<term>Quit <replaceable>appname</replaceable></term>
<listitem>
<para>
Quit the application. If there are unsaved changes in any of the currently open documents then the user should be presented with a dialog listing those documents and giving the option to save all, discard all, or cancel. Save All should behave like the File|Save command applied to every unsaved document. If there are no unsaved changes then the application should quit with no further interaction with the user. The label of the Quit menu item should include the name of the application.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Close All</term>
<listitem>
<para>
Close all open documents. If there are unsaved changes in any of the currently open documents then the user should be presented with a dialog listing those documents and giving the option to save all, discard all, or cancel. Save All should behave like the <menuchoice><guimenu>File</guimenu> <guimenuitem>Save</guimenuitem></menuchoice> command applied to every unsaved document. For an SDI application, <guimenuitem>Close All</guimenuitem> should leave the user with a blank document, and with a controlled SDI application the user should be left with the controlling window.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

</sect3>

<sect3 id="menu-standard-edit">

<title>Edit</title>

<para>
<literallayout class="monospaced">_Edit
    _Undo <replaceable>action</replaceable>        Ctrl-Z
    _Redo <replaceable>action</replaceable>        Ctrl-Shift-Z
    ---
    Cu_t                Ctrl-X
    _Copy               Ctrl-C
    _Paste              Ctrl-V
    _Delete             Del
    ---
    Select _All         Ctrl-A
    Select _None        Ctrl-Shift-A
    ---
    Find                Ctrl-F
    Replace             Ctrl-R</literallayout>
</para>

<para>
The <guimenu>Edit</guimenu> menu should contain items relating to editing the document, clipboard handling, selection and searching and replacing.
</para>

<sect4>

<title>Modification History</title>

<para>
Document-editing applications are recommended to maintain a history of modifications to a document and the state of the document between each action. The Undo and Redo commands are used to move through this history. The <guimenuitem>Undo</guimenuitem> and <guimenuitem>Redo</guimenuitem> items on the menu should preferably include the name of the action they will undo or redo. They should always be separate menu items with separate keyboard shortcuts, even if the application is capable of only one undo level.
</para>

<variablelist>

<varlistentry>
<term>Undo <replaceable>action</replaceable></term>
<listitem>
<para>
Undoes the previous action in the history. The document should be changed to the state it was in before the previous action was performed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Redo <replaceable>action</replaceable></term>
<listitem>
<para>
Redoes the following action in the history. After the user has travelled back through the modification history with the <guimenuitem>Undo</guimenuitem> command, the <guimenuitem>Redo</guimenuitem> command should move the user forwards through that history and change the document state to the state it was in after that action had been performed.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

<sect4>

<title>Clipboard Access and Deletion</title>

<variablelist>

<varlistentry>
<term>Cut</term>
<listitem>
<para>
Removes the contents of the current selection and places it onto the clipboard. The current selection should be removed in the same manner as <guimenuitem>Delete</guimenuitem>. This command should only be available when a section of the document is selected.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Copy</term>
<listitem>
<para>
Copies the contents of the current selection onto the clipboard. This command should only be available when a section of the document is selected.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Paste</term>
<listitem>
<para>
Inserts the contents of the clipboard at the caret or, if part of the document is selected, replaces the selection with the clipboard contents.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Delete</term>
<listitem>
<para>
Deletes the current selection. This should remove the current selection or perform an equivalent action such as blanking out an area of an image.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

<sect4>

<title>Manipulating the Selection</title>

<variablelist>

<varlistentry>
<term>Select All</term>
<listitem>
<para>
Selects all parts of the document.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Select None</term>
<listitem>
<para>
Deselects all parts of the document. 
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

<sect4>

<title>Searching and Replacing</title>

<variablelist>

<varlistentry>
<term>Find</term>
<listitem>
<para>
Brings up a Find dialog.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Replace</term>
<listitem>
<para>
Brings up a Replace dialog. 
</para>
</listitem>
</varlistentry>

</variablelist>

</sect4>

</sect3>

<sect3 id="menu-standard-options">

<title>Options</title>

<para>
<literallayout class="monospaced">_Options
    <replaceable>appname</replaceable> _Options...
    <replaceable>specific options...</replaceable>
    ---
    <replaceable>checkbox and radiobutton options</replaceable></literallayout>
</para>

<para>
In reality, there needs to be a proper analysis of application configuration mechanisms. There are a number of different models, with no obvious consensus. Consideration needs to be given to, among other things, the distinctions between application, window and document settings, how multiple running instances of the same application interact, etc.
</para>

<para>
Developers are encouraged to put settings that are likely to be changed frequently in the menu as checkboxes or radiobutton groups.
</para>

</sect3>

<sect3 id="menu-standard-help">

<title>Help</title>

<para>
<literallayout class="monospaced">_Help
    _Search Help
    Help _Contents      F1
    _About <replaceable>appname</replaceable></literallayout>
</para>

<variablelist>

<varlistentry>
<term>Search Help</term>
<listitem>
<para>
Brings up a dialog allowing the user to search the application's documentation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Help Contents</term>
<listitem>
<para>
Brings up the default gnome help browser with the contents page of the application's documentation.
</para>
</listitem>
</varlistentry>

<!-- What about context-sensitive help? How will that work? Do we want to give it the F1 shortcut? -->

<varlistentry>
<term>About <replaceable>appname</replaceable></term>
<listitem>
<para>
Brings up the About dialog for the application. The dialog should contain the name and version number of the program, a short description of what the program does, contact details of the authors, a copyright notice, and a pointer to the license under which the program is made available.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect3>

</sect2>

<sect2 id="toolbar-layout">
	
<title>Toolbar Layout</title>

</sect2>

</sect1>

<sect1 id="dialogs">
  
<title>Dialogs</title>

<!-- TODO:
- Double-clicking to close a dialog
-->
	
<sect2 id="dialog-principles">
	
<title>General Principles</title>

<para>
Dialog boxes are windows allowing the user to interact with an application in ways that supplement the main application window. They might typically be used to control the properties of an object, to request further information from the user or to notify the user of an event.
</para>

<para>
Dialog boxes come in a number of different forms, suitable for different situations, and each with their own UI implications.
</para>

<sect3 id="dialogs-types">

<title>Types of dialog boxes</title>

<sect4 id="dialogs-modal-and-modeless">

<title>Modal and modeless dialog boxes</title>

<para>
All dialogs can be classified according to whether they are modal or modeless. Modal dialog boxes are those which prevent the user from interacting with any other part of the application while they are visible. They should be used only where it is necessary that the user doesn't make any changes to the state of the program before performing an action with the dialog or closing it.
</para>

<para>
Modeless dialog boxes allow the user to continue to interact with the rest of the application while the dialog is visible. They are generally suitable for tasks such as changing the properties of an object or tool.
</para>

<para>
In general, modeless dialogs are preferable to modal dialogs since they are less intrusive. Dialogs should only be made modal if there is a compelling reason to do so.
</para>

</sect4>

<sect4 id="dialogs-informational">

<title>Informational dialog boxes</title>

<para>
Informational dialog boxes are those which do not require the user to enter any data or make choices; they are merely for notification purposes.  These dialogs typically only need a label for the user to read and a button to close the dialog. They can be modal or modeless as appropriate.
</para>

</sect4>

<sect4 id="dialogs-druids">

<title>Druids</title>

<para>
Druids are dialog boxes which lead the user through a sequence of steps. They are frequently used for software installation and configuration, though they are by no means limited to this role.
</para>

<para>
Druids are best suited to situations in which the user requires some sort of <quote>hand-holding</quote>, due to the way in which they can combine documentation and functionality. Experienced users tend to find them inefficient and patronising.
</para>

<para>
GNOME's druids are roughly equivalent to the <quote>Wizards</quote> frequently found in Microsoft Windows.
</para>

</sect4>

</sect3>

<sect3 id="dialogs-layout">

<title>Dialog box layout</title>

<para>
Note that the left-right positioning of items described here only applies to Western systems. Localisation for other countries may change these positions.
</para>

<para>
The top portion of a dialog box should contain the main area, the content of which is very much up to the developer.
</para>

<para>
At the bottom of the dialog window should be a single row of buttons which pertain to the whole dialog. These can be divided into four main types: Action buttons, closing buttons, navigation buttons and help buttons.
</para>

<para>
These buttons should be laid out as follows: Action or navigation buttons should be on the extreme right. Closing buttons should be to the left of any action or navigation buttons. A help button should be on the extreme left.
</para>

</sect3>

<sect3 id="dialogs-behaviour">

<title>Dialog box behaviour</title>

<para>
Dialogs should reflect the current state of the application. If changes are made to the state of the application while the dialog is on the screen then these changes should be immediately visible in the dialog.
</para>

<para>
Care should be taken to ensure that it is obvious to the user whether changes made within the main area will immediately affect objects external to the dialog or whether the user will have to perform another action to apply those changes. For example, the presence of a button labeled <quote>Apply</quote> would imply that any changes would only be applied once that button had been pressed, while the presence of only a button marked <quote>Close</quote> would imply that changes were applied immediately.
</para>

<para>
Nothing in the main area of the dialog should dismiss the dialog. Any actions which will dismiss the dialog should be confined to the bottom row of buttons.
</para>

</sect3>

<sect3 id="dialogs-buttons">

<title>Dialog box buttons</title>

<para>
These dialogs should be positioned on the bottom row of the dialog according to the rules specified above. Action and navigation buttons should only be enabled while it makes sense for the user to press them. Closing buttons should always be enabled; it should always make sense for the user to press them.
</para>

<sect4 id="dialogs-buttons-action">

<title>Action buttons</title>

<para>
Most dialogs will have buttons to perform some kind of action. These should be labelled with a verb to describe the action. (Labels such as <quote>OK</quote>, <quote>Yes</quote> and <quote>No</quote> are discouraged since they are difficult for the user to quickly scan for the desired action.) The leftmost action button should be the default button, and so be activated by the Enter key in addition to any other accelerators it may possess.
</para>

<para>
On modal dialogs the action button should also close the dialog. On modeless dialogs either all action buttons should close the dialog or none should.
</para>

</sect4>

<sect4 id="dialogs-buttons-closing">

<title>Closing buttons</title>

<para>
Closing buttons vary depending on the type of dialog on which they appear. On dialogs which are closed by their action buttons there should be a Cancel button which should close the dialog and return the application to the state it was in before the dialog was shown.
</para>

<para>
On dialogs which are not closed by their action button there should be a Close button which should close the dialog without making any further changes to the state of the application.
</para>

<para>
The situation is slightly different again for informational dialogs. As always, the closing button should close the dialog, but the labelling of the button is a decision for the developer and is dependent upon the context in which it appears. As a rough guide, <quote>Close</quote> will generally be an appropriate label for dialogs appearing in response to a user's request for information, while <quote>OK</quote> will often be more appropriate for unrequested alerts.
</para>

<para>
In all of these cases the closing button should be activated by the escape key. On purely informational dialogs where the dismiss button is the only button in the bottom row of the dialog, it should also be the default button and so be activated by the Enter key.
</para>

</sect4>

<sect4 id="dialogs-buttons-navigation">

<title>Navigation buttons</title>

<para>
If the dialog contains a sequence of steps (as in a druid, for example), they should be navigable with Next and Previous buttons.
</para>

</sect4>

<sect4 id="dialogs-buttons-help">

<title>Help buttons</title>

<para>
Developers are encouraged to give their dialogs a Help button. This should launch the default help browser with the section of the application's help document relevant to the current dialog.
</para>

</sect4>

</sect3>

<sect3 id="dialogs-window-titles">
<title>Dialog Window Titles</title>

<para>
Dialog windows should be given titles that enable the user to determine from the title alone both the task that the dialog is intended to carry out and the parent window (if any) that the task applies to. So, for example, the title for a search and replace dialog in a text editor should look something like: <quote>Replace in document.txt</quote>.
</para>

</sect3>

</sect2>

<sect2 id="standard-dialogs">
	
<title>Standard Dialogs</title>

<para>
GNOME provides a number of standard dialogs which should be used wherever appropriate.
</para>

<sect3>

<title>File Selector</title>

<para>
The file selector should be used whenever the user is required to select one filename, either of a file that already exists or the desired name of a file that is to be created.
</para>

<para>
If the file selector is being used to select a file that is to be opened in the application then its title should be <quote>Open File</quote>. If it is being used to choose a filename to save a file to then its title should be <quote>Save File</quote>.
</para>

<para>
Sometimes it may be appriate to extend the file selector to include new features. For example, if an application is capable of saving a document in multiple different file formats then the file selector should include a mechanism for selecting the desired file type.
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="controls">

<title>Controls</title>

<para>
The GNOME environment provides a set of controls (also known as widgets<!-- FIXME: which should we use? -->) for use in your applications. It is important that controls are used appropriately and that they follow standard behaviours since this allows users to predict the effects of their actions. Controls which behave in non-standard ways dilute the meaning of the GUI's visual language.
</para>

<para>
Under some circumstances the value that a control manipulates may not have an effect, or the action that a control activates may not be able to run. At these times the control should be made unavailable. While a control is unavailable it will appear dimmed and will not be able to receive the focus.
</para>

<sect2 id="controls-buttons">

<title>Buttons</title>

<para>
Buttons should be used to initiate actions.
</para>

<para>
Buttons should generally be labeled with verbs. Button labels should have the first letter of the first word and of any significant words capitalised. Where the action will require further input from the user before it can be carried out, the label should end with an ellipsis ("...").
</para>

<para>
In a dialog, one button may be made the default button. The guidelines for doing this are in the section on dialogs.
</para>

</sect2>

<sect2 id="controls-toggle-buttons">

<title>Toggle Buttons</title>

<para>
Toggle buttons are buttons which remain depressed after they have been clicked on. They can be used to indicate a currently active mode, and should work in the same manner as either radio buttons or check boxes. They may be raised either by a second click, or by another toggle button in the same group being clicked on.
</para>

<para>
Toggle buttons should generally only be used where there is little available space, such as on toolbars or palettes. Otherwise check boxes or radio buttons will be more appropriate.
</para>

</sect2>

<sect2 id="controls-check-boxes">

<title>Check Boxes</title>

<para>
Check boxes are used to toggle an option on or off. Check box options should be independent of each other. Toggling a check box should not affect the values of other controls. 
</para>

<para>
Toggling a check box may affect the availability of other controls. Where this happens, the check box should ideally be placed immediately above or to the left of the controls it affects, in such a way as to indicate that the controls are dependent on the state of the check box.
</para>

<para>
While a check box option may be applied instantaneously, changing it should not initiate an action.
</para>

<para>
Check boxes should be labeled in a way that unambiguously indicates what the effects of both their checked and unchecked states will be. Where this cannot be done, it may be better to use two radio buttons so that both states can be given labels.
</para>

</sect2>

<sect2 id="controls-radio-buttons">

<title>Radio Buttons</title>

<para>
Radio buttons are used in groups to select from a mutually exclusive set of options. Only one radio button within a group may be checked at any one time. As with check boxes, radio buttons should not be used to initiate actions.
</para>

</sect2>

<sect2 id="controls-option-menus">

<title>Option Menus</title>

<para>
Option menus are used to select from a mutually exclusive set of options. They should not be used to initiate actions.
</para>

<para>
In general, radio buttons are preferable to option menus, since options menus only display the currently selected item. However, their use may be appropriate when there is little available space or where the list of options may change.
</para>

</sect2>

<sect2 id="controls-combo-boxes">

<title>Combo Boxes</title>

<para>
Combo boxes combine a text entry field and a menu of predefined values. Selecting one of the pre-defined values from the menu should update the contents of the text field to that value and may also perform the action that would be performed if the user pressed the Return key in that text field.
</para>

</sect2>

<sect2 id="controls-progress-bars">

<title>Progress Bars</title>

<para>
Progress bars are visual indicators of the progress of a task being carried out by the application. <!-- would it be good to have a section on feedback? -->
</para>

<para>
There are two types of progress bar: Determinate progress bars, which indicate what proportion of the task has been completed, and indeterminate progress bars, which indicate only that the application is working on a task. Where the length of a task is known, a determinate progress bar should be used. Otherwise, an indeterminate progress bar should be used.
</para>

</sect2>

<sect2 id="controls-status-bars">

<title>Status Bars</title>

<para>
Status bars provide a small area which can be used to display one line of text describing the status of the application. Status bars should always be positioned at the bottom of a window.
</para>

<para>
Status bars should only contain information which it is not critical that the user sees. Important information should be presented to the user by other means.
</para>

</sect2>

</sect1>

<sect1 id="layout">

<title>Layout</title>

<!-- TODO:
- More than any other section this needs to be liberally sprinkled with examples
-->

<para>
The layout of a GUI is important both because it communicates the relationships between elements, and because an aesthetically-pleasing interface is more pleasant to use.
</para>

<sect2 id="layout-order-relationships">

<title>Order and Relationships</title>

<para>
Western users are accustomed to reading from the top-left to the bottom-right. For this reason, elements of an interface which are intended to be presented to the user in a specific order should be laid out in such a way that the first element the user should encounter is in the top-left and the last in the bottom-right.
</para>

<para>
(Bear in mind that when localized for non-western locales, interfaces may be reversed so that they read from right to left.) <!-- Does it get more complex than this? -->
</para>

<para>
Relationships between elements are usually indicated by their positions. Labels should be placed either above or to the left of the controls they relate to.
</para>

</sect2>

<sect2 id="layout-aesthetics">

<title>Aesthetics</title>

<para>
Simply making a GUI look tidier can make it seem less intimidating. This can be done by aligning elements with each other and by removing unnecessary elements.
</para>

<para>
GUI's are rarely pleasant to look at when the elements are densely packed onto the screen, and for this reason the elements in a GUI should be given adequate space between each other. The space between elements is frequently referred to as <quote>white space</quote>.
</para>

</sect2>

<sect2 id="layout-grouping-separators">

<title>Grouping and Separators</title>

<para>
There is a rule, frequently referred to in interface design, called the 7+/-2 rule. It states that humans can only hold between 5 and 9 items of information in their minds at a time. One of the implications of this in interface design is that long lists of choices should, where possible, be broken down into smaller groups of choices.
</para>

<para>
There are a number of ways of visually dividing controls into groups. One method is to use separators and frameboxes to draw lines and boxes between elements. Another method is to use a greater amount of white space between groups of elements.
</para>

<para>
It is essential that the extent of option groups such as radio buttons be made clear, using these methods as appropriate.
</para>

</sect2>

</sect1>

<sect1 id="terminology">
  
<title>Terminology</title>
	
</sect1>

<sect1 id="keyboard-and-mouse-input">
  
<title>Keyboard and Mouse Input</title>
	
</sect1>

<sect1 id="reality-checks">
  
<title>Reality Checks</title>
	
</sect1>

</article>
