<?xml version="1.0" standalone="no"?>
<?xml-stylesheet type="text/xml" href="params.xsl"?>
<!-- vim: set ai tw=80 ts=3 sw=3 et: -->

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [

<!ENTITY malcolm-email "<email>malcolm@commsecure.com.au</email>">
<!ENTITY autoconf "<application>Autoconf</application>">
<!ENTITY automake "<application>Automake</application>">
<!ENTITY gettext "<application>gettext</application>">
<!ENTITY libgnome "<application>libgnome</application>">
<!ENTITY libgnomeui "<application>libgnomeui</application>">
<!ENTITY bas "<application>bonobo-activation-server</application>">
<!ENTITY intltool "<application>intltool</application>">
<!ENTITY glade "<application>Glade</application>">
<!ENTITY gconf "<application>Gconf</application>">
<!ENTITY cvs "<application>cvs</application>">
<!ENTITY autogen.sh "<filename>autogen.sh</filename>">
<!ENTITY configure.in "<filename>configure.in</filename>">
<!ENTITY Makefile.am "<filename>Makefile.am</filename>">
]>

<article>
   <articleinfo>
      <title>Internationalising GNOME applications</title>
      <author>
         <firstname>Malcolm</firstname><surname>Tredinnick</surname>
         <affiliation>
            <address>&malcolm-email;</address>
         </affiliation>
      </author>
      <copyright>
         <year>2002</year>
         <holder>Malcolm Tredinnick</holder>
      </copyright>
      <legalnotice id="legalnotice">
         <para>Permission is granted to copy, distribute and/or modify this
         document under the terms of the <citetitle>GNU Free Documentation
         License</citetitle>, Version 1.1 or any later version published by the
         Free Software Foundation with no Invariant Sections, no Front-Cover
         Texts, and no Back-Cover Texts.  A copy of the license can be found
         <ulink url="FIXME">here</ulink> or in the file COPYING-DOCS which
         shipped as part of this package. </para>

         <para>Translators are given permission to use the current title of
         this document in any translated versions. </para>

         <para>Many of the names used by companies to distinguish their
         products and services are claimed as trademarks. Where those names
         appear in any GNOME documentation, and those trademarks are made aware
         to the members of the GNOME Documentation Project, the names have been
         printed in caps or initial caps. </para>

      </legalnotice>

      <revhistory>
         <revision>
            <revnumber>0.1</revnumber>
            <date>3 November 2002</date>
            <revdescription>
               <para>Initial version. This document is maintained in the <ulink
               url="http://cvs.gnome.org">GNOME CVS repository</ulink>. It is
               in the <filename class="directory">gnome-devel-docs</filename>
               module under <filename
               class="directory">gnome-devel-docs/tutorials/i18n</filename>
               </para>
            </revdescription>
         </revision>
      </revhistory>

   </articleinfo>

   <abstract>
      <para>Once a GNOME application has reached a sort of &quot;critical mass
      &quot;, it becomes important to think about how to make it available to
      people who speak other languages. This tutorial covers the steps required
      to internationalise an application in a fashion that is consistent with
      the rest of GNOME. It is mostly aimed towards applications written in C,
      but the principles and support structure apply to all applications.</para>
   </abstract>

   <sect1 id="introduction">
      <title>Introduction</title>

      <para>It is probably not unreasonable to claim that most computer
      programs are written in some form of English. Certainly many popular
      programming languages use English as the inspiration for their keywords
      and a lot of projects with international collaborators will have
      (possibly implicit) guidelines to use English for comments and displayed
      messages. </para>

      <para>That being said, the majority of people on this planet (and
      possibly other planets as well) do <emphasis>not</emphasis> understand
      English, or if they do, prefer another language in day to day life. So
      GNOME applications wishing to reach an audience as wide as possible need
      to be translated into other languages. At the time of writing, the latest
      stable release of GNOME has had at least some portions translated into 55
      different languages. </para>

      <para>In this document, we will cover the process of
      <firstterm>internationlisation</firstterm> (usually abbreviated as
      <abbrev>i18n</abbrev>). This is the phase in an application's development
      where the developers incorporate the pieces needed to assist the
      translators and to subsequently display any message using the translated
      version for the appropriate locale. </para>

      <para>The process of translating any messages in the program into another
      language is called <firstterm>localisation</firstterm> (or
      <abbrev>l10n</abbrev>) and is covered elsewhere, such as in <xref
      linkend="bib-kmaraas"/>. </para>

      <para>Internationalising your application consists of two phases. In the
      <xref linkend="preparing-source"/> section, we work through the process
      of marking up strings for translation throughout the source code. I will
      also mention any changes that have to be made to the source code to keep
      it buildable. In the next section, <xref linkend="build-changes"/>, I
      will talk about changes to the applications build process, such as
      makefiles and <filename>configure.in</filename> changes. </para>

      <sect2 id="feedback" xreflabel="feedback">
         <title>Feedback</title>

         <para>If you use this tutorial to internationalise an application and
         encounter difficulties, let me know. I would be pleased to know of
         areas which are unclear, misleading or just plain missing. Send email
         to &malcolm-email;. </para>

      </sect2>

   </sect1>

   <sect1 id="preparing-source" xreflabel="preparing the source">
      <title>Preparing the source code for translation</title>

      <para>At the heart of the i18n process lies the fact that you have to
      track down every single string that will ever be seen by the users and
      mark them as translatable. This is not necessarily an easy job. A medium
      to large application could have hundreds of strings. The strings have a
      tendency to hide in files that you might otherwise forget about, too.
      Fortunately there are tools available to assist with getting this
      process off the ground. Plus you do not need to catch every string the
      first time around. A partially marked-up application will still work
      normally. The only problem is that the &quot;invisible&quot; strings will
      not be translated. </para>

      <para>The next few sections describe the individual steps of this
      process.
         <itemizedlist>
            <listitem>
               <para>Declaring the necessary functions. </para>
            </listitem>
            <listitem>
               <para>Initialising the system library
               (<filename>libc</filename> or <filename>glibc</filename>)
               support. </para>
            </listitem>
            <listitem>
               <para>Finding and marking all strings in the source code. </para>
            </listitem>
            <listitem>
               <para>Marking all visible strings in support files. </para>
            </listitem>
         </itemizedlist>
      </para>

      <sect2 id="i18n-header" xreflabel="i18n header file">
         <title>The i18n header file</title>

         <para>Throughout this tutorial, the goal is always to keep your
         application buildable. Since you are about to wrap strings in some new
         function calls, you need to make sure your program knows about these
         functions. Then you initialise the i18n code at the beginning of your
         application and go through the code marking up strings. </para>

         <sect3>
            <title>The international header file</title>
 
            <para>Create a new header file which will contain the various i18n
            macros. The following listing is a reasonable example to follow.
            </para>

            <example>
               <title><filename>slice-i18n.h</filename></title>

<programlisting><![CDATA[
#ifndef __SLICE_INTL_H__
#define __SLICE_INTL_H__

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

#ifdef ENABLE_NLS
#include <libintl.h>
#define _(String) gettext(String)
#ifdef gettext_noop
#define N_(String) gettext_noop(String)
#else
#define N_(String) (String)
#endif
#else /* NLS is disabled */
#define _(String) (String)
#define N_(String) (String)
#define textdomain(String) (String)
#define gettext(String) (String)
#define dgettext(Domain,String) (String)
#define dcgettext(Domain,String,Type) (String)
#define bindtextdomain(Domain,Directory) (Domain) 
#define bind_textdomain_codeset(Domain,Codeset) (Codeset) 
#endif /* ENABLE_NLS */

#endif /* __SLICE_INTL_H__ */
]]></programlisting>
            </example>

            <note>
               <para>For the sake of examples in this tutorial, I am going to
               be working with a mythical project called
               <literal>Slice-n-Dice</literal>. I do not know what this
               application does, but it is definitely going to be available to
               an international audience. </para> </note>

            <para>Naturally, you may want to call your file something other
            than <filename>slice-i18n.h</filename>. You should not change the
            <literal>ENABLE_NLS</literal> variable's name, though, since that
            has special meaning when we come to the <xref
            linkend="build-changes"/> section. </para>

            <para>If your application has &libgnome; as a dependency, then you
            can avoid creating your own i18n support file by just including the
            <filename
            class="headerfile">&lt;libgnome/gnome-i18n.h&gt;</filename> file
            instead of <filename>slice-i18n.h</filename> (or your replacement
            name). I am including the above for the benefit of application
            developers working lower down the metaphorical food chain. </para>

            <para>For library developers, some modifications to the above file
            may be necessary. The following sections still apply, but you may
            wish to skip ahead to the section about <xref
            linkend="special-for-libraries"/> to find out the couple of lines
            that need to be changed here. </para>

            <para>In a moment, I will describe the purpose of each of those
            functions, but the important point from a developer point of view
            is that you are about to start wrapping strings up
            in <literal>_()</literal> and <literal>N_()</literal> calls. If you
            use those functions in a source file, you need to make sure you
            have included the above header file. Of course, failure to do this
            will be fairly obvious; your application simply will not build,
            since a few functions will be undeclared. </para>

         </sect3>

         <sect3 id="initialising-i18n-support">
            <title>Initialising the i18n support code</title>

            <para>In case you do not have an intimate understanding of GNU's
            &gettext; application, here is a brief explanation of the big
            picture before we get into the actual code changes you need to
            make. I am glossing over some details here and mostly concentrating
            on the parts that are relevant to GNOME. If you want to read all
            the fine print, the &gettext; manual (see <xref
            linkend="bib-gettext"/>) is excellent.</para>

            <para>The collection of all translated strings on your
            installation is divided into different <firstterm>message
            domains</firstterm>. Almost always, each separate application or
            library is a different domain and the domain is usually named after
            the package. The strings for a given domain are compiled into an
            efficient binary format (one file for each locale) at install time
            and installed along with the package. Not surprisingly, we need to
            tell our program where these files are installed so that it can
            look them up when required.</para>

            <para>A single application may not always return messages from just
            one domain. Obviously, all its own messages will come from the
            application's domain, but it may also call library functions that
            return or display translated strings and they will most likely come
            from the library's own domain. So facilities exist in the C library
            to change the currently active domain (of which there can only ever
            be one). </para>

            <para>A final point of significance is that translated strings have
            to be encoded somehow when they are passed around.
            <literal>ASCII</literal> or <literal>ISO8859-1</literal> encodings,
            which are common for English-speaking locales are not appropriate
            if you are working in Chinese or Russian. By default, &gettext;
            knows which is the most natural encoding for a given locale setting
            and will return the strings in the appropriate encoding. However,
            throughout GNOME all strings are encoded in UTF-8 so you end up
            having to re-encode the strings from their native encoding to
            UTF-8. Fortunately, we can tell the C library this and it will not
            bother doing the locale-specified encoding, which saves some time
            on each and every string lookup. </para>

            <para>The last three paragraphs were just an extremely verbose way
            of describing what the following three lines of code do. These
            should be just about the first three lines of code you put in the
            <literal>main()</literal> function of your application, since you
            really want to be ready to handle user visible strings as early as
            possible. If you are writing a library that will be used by client
            applications, you need to put the first two lines from here into
            your library's initialisation function. </para>
<programlisting>
bindtextdomain (GETTEXT_PACKAGE, SLICELOCALEDIR);
bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
textdomain (GETTEXT_PACKAGE);
</programlisting>

            <para>I should explain what is happening here: The
            <literal>GETTEXT_PACKAGE</literal> variable is defined by your
            build process (usually in <filename>configure.in</filename>) and is
            the name of the message domain for this application. So its value
            can be set to the name of your program. The
            <literal>SLICELOCALEDIR</literal> variable (the name is usually
            based on the application name, but that is entirely arbitrary and
            up to you) is defined at build time and is the root of the
            directory hierarchy that will store the message catalogs. The
            compiled message catalogs will be installed into the directory
            <filename><replaceable>SLICELOCALEDIR</replaceable>/<replaceable>locale</replaceable>/LC_MESSAGES/<replaceable>GETTEXT_PACKAGE</replaceable>.mo</filename>.
            </para>

            <note>
               <para>In general, the <literal>LC_MESSAGES</literal> component
               can be any category name (see the
               <citerefentry><refentrytitle>locale</refentrytitle>
               <manvolnum>7</manvolnum></citerefentry> manual page for more
               explanation). In GNOME, you will only have to deal with
               <literal>LC_MESSAGES</literal>, so I will ignore the others.
               </para>
            </note>

            <para>The above code fragment, then, tells your application
               <itemizedlist>
                  <listitem>
                     <para>where to find the message catalogs; </para>
                  </listitem>
                  <listitem>
                     <para>to use UTF-8 for the encoding for all strings;
                     </para>
                  </listitem>
                  <listitem>
                     <para>initially, at least, translate using strings from
                     this application's domain. </para>
                  </listitem>
               </itemizedlist>
               
               This last item is no good for a library (the client application
               controls the active domain most of the time), so you do not need
               to do it there. Instead, a library has to set the message
               domain before retrieving one of its own strings and then restore
               it against afterwards (more details on this later). </para>

               <para>It should be noted in passing that the if you are using an
               i18n header file like the one in the last section, the above
               code fragment will compile regardless of whether you have i18n
               support available or not. That is the benefit of the header file
               from the previous section: once you have set that up, you can
               deal with the rest of the code as though i18n support is always
               available and it will be just be built as an empty operation if
               the support is not present. </para>

               <note>
                  <para>As I was writing this I noticed that the <filename
                  class="headerfile">libgnome/gnome-i18n.h</filename> header
                  file does not define
                  <literal>bind_textdomain_codeset()</literal> in the case when
                  <literal>ENABLE_NLS</literal> is not defined. So your package
                  may need to treat that function (only) as a special case if
                  you are reusing code from &libgnome;.  </para>
               </note>

         </sect3>

      </sect2>

      <sect2 id="marking-strings" xreflabel="marking strings">
         <title>Marking translatable strings</title>

         <para>You are now at the point where you can begin the task of marking
         all appropriate strings for translation. Note that not every single
         string needs to be so marked. Strings that are not visible to the user
         should usually be left alone (since that way all your configuration
         files and so on are going to be locale independent). You may wish for
         some portions of error messages to not be translated (so that the user
         can cut and paste those messages into an email to you and you will be
         able to understand them and grep them out of the code). Usually, it is
         not necessary to translate names, although see the <xref
         linkend="tips"/> section for what happens in the
         <emphasis>about</emphasis> box of an application. </para>

         <sect3>
            <title>Source code files</title>

            <para>As an initial attempt to ferret out all the likely strings
            from your C or C++ source code, run the command
            <userinput>xgettext -a -o my-strings --omit-header *.c
            *.h</userinput> from your source directory. </para>
<!-- <programlisting>
xgettext -a -o my-strings omit-header *.c *.h
</programlisting>
-->

            <para>This will run through every <literal>.c</literal> and
            <literal>.h</literal> file in the current directory and extract all
            of their strings into a file caled <filename>my-strings</filename>.
            This file is very similar to what translators work with when
            translating, but the key thing at the moment is to look at the
            format of each line. You will see that they look like
<programlisting>
#: slice-n-dice.c:36
msgid "Sharpening the knives and preparing for action."
msgstr ""
</programlisting>
            This tells you that the given string is in the file
            <filename>slice-n-dice.c</filename> at line number 36. So, if you
            decide that that string should be translated, open up the file and
            put <literal>_(</literal> before the string and a matching
            <literal>)</literal> just after it. So, you may have some code that
            used to say
<programlisting>
popup_display ("Sharpening the knives and preparing for action.");
</programlisting>
            and it will now read
<programlisting>
popup_display (_("Sharpening the knives and preparing for action."));
</programlisting>
            </para>

            <para>There is one problem with this markup scheme. Since
            <literal>_()</literal> is a function call, you cannot use it in all
            circumstances. For example, if you are initialising a static array
            with some strings, you are not permitted to call a function in the
            initialiser portion of the statement. Consider code that looks like
            the following.
<programlisting>
ShapeData shapes[] = {"circle", "square", "triangle", NULL};
</programlisting>
            In this case, you should use the <literal>N_()</literal> macro to
            mark up these strings. This macro ultimately does nothing, but when
            the &gettext; tools are scanning the code looking for translatable
            strings, they can be told to look for this type of markup and also
            extract those strings. The above example then becomes
<programlisting>
ShapeData shapes[] = {N_("circle"), N_("square"), N_("triangle"), NULL};
</programlisting>
            </para>

            <para>Once you have marked up some strings with
            <literal>N_()</literal> you then need to find all the places where
            those strings are used in the code and wrap the code that produces
            the string in a <literal>_()</literal>. This is because it is the
            <literal>_()</literal> that performs the message lookup and
            translation function. Continuing the above example, we might have
            code (after i18n marking) that looks like this.
<programlisting>
for (i = 0; shapes[i] != NULL; ++i)
    show_shape_name (_(shapes[i]));
</programlisting>
            Notice how the retrieval of the string from
            <literal>shapes[]</literal> is now passed through a call to
            <literal>_()</literal> so that the
            <literal>show_shape_name()</literal> function sees the
            <emphasis>translated</emphasis> string, not the original version.
            This part of the code markup is probably the trickiest bit to get
            right, since it is not uncommon to overlook a place where a static
            string is actually being used (although the string itself may be
            marked up correctly with <literal>N_()</literal>). </para>

            <para>Once you have gone through every string in the
            <filename>my-strings</filename> file created earlier and determined
            if they should be translated or not, you can delete that file. It
            was just an aid to getting the process going. At this point (as
            always) your code should still build and run normally, although the
            i18n portion will still not work (all the special markup comes out
            as no-ops since <literal>ENABLE_NLS</literal> is undefined). It is
            worth testing this as you go along to avoid problems later.</para>

            <sect4 id="special-for-libraries" xreflabel="library markup
            requirements">
               <title>Special requirement for libraries</title>

               <para>If you are writing a library, almost everything written
               previously applies as with a standalone application. The only
               problem that arises is that a library will never really know
               what message domain is currently active when it is processing a
               string and you usually want to have the library's own domain
               active at that point. The simplest solution to this problem is
               to change one of the defintions in the i18n header file
               mentioned in the <xref linkend="i18n-header"/> section. Find the
               line that says
<programlisting>
#define _(String) gettext(String)
</programlisting>
               and change it to read
<programlisting>
#define _(String) dgettext(GETTEXT_PACKAGE, String)
</programlisting>
               In this way, all strings that pass through the
               <literal>_()</literal> function will be translated in the domain
               of the library all the time. </para>

               <para>One other situation that arises very rarely may be worth
               knowing about. In &libgnomeui;, for example, there are functions
               that operate on arbitrary arrays of strings (menu items, in this
               case). Some of those strings are standard and have been
               translated in the library itself. Others will have been supplied
               by the client application and translated in that domain. So
               &libgnomeui; defines the following function and convenience
               macro. </para>

               <example>
                  <title>Code from
                  <filename>libgnomeui/gnome-app-helper.c</filename></title>

<programlisting><![CDATA[
#define L_(x) gnome_app_helper_gettext (x)

const gchar *
gnome_app_helper_gettext (const gchar *str)
{
        char *s;

        s = gettext (str);
        if ( s == str )
                s = dgettext (GETTEXT_PACKAGE, str);

        return s;
}
]]></programlisting>
               </example>

               <para>Strings marked with <literal>L_()</literal> are thereby
               translated in the currently active domain if possible and the
               library's domain otherwise. You may wish to duplicate this code
               if you have similar circumstances. </para>

            </sect4>

         </sect3>

         <sect3>
            <title>Desktop files</title>

            <para>Desktop files are used in GNOME as a means to determine which
            menu an application should appear under in the panel menus. It also
            contains a descriptive string that appears as a tooltip when the
            application is on the panel, along with information about how to
            run the application and what icon to show. </para>

            <para>From an internationalisation point of view, the interesting
            parts of a <filename>.desktop</filename> are the
            <literal>Name</literal> and <literal>Comment</literal> fields. They
            are the only two fields used in GNOME 2 that are defined as
            translatable in the desktop file <ulink
            url="http://www.freedesktop.org/standards/desktop-entry-spec/desktop-entry-spec.html#RECOGNIZED-KEYS">specification</ulink>.
            </para>

            <para>To mark these fields as translatable, copy your desktop file,
            <filename>slice-n-dice.desktop</filename>, to
            <filename>slice-n-dice.desktop.in</filename> (the
            <literal>.in</literal> suffix is traditional). Then put an
            underscore before the <literal>Name</literal> and
            <literal>Comment</literal> tags. So, after markup, the file might
            look like this. </para>

            <example>
               <title><filename>slice-n-dice.desktop.in</filename></title>
<programlisting>
[Desktop Entry]
Encoding=UTF-8
_Name=Slice 'n' Dice
_Comment=Chop things up into shapes
Exec=slice-n-dice
Icon=slice-n-dice.png
Terminal=false
Type=Application
Categories=GNOME;Application;
</programlisting>
            </example>

            <tip>
               <para>Everytime you change a file like this to acommodate
               translations, keep a note of the filename. This applies both for
               this section and for the file types mentioned in the next few
               sections as well. Later, in <xref linkend="makefile-changes"/>
               you will need to make some build changes to utilise these new
               files, so having a list will save you from missing any of them.
               </para>
            </tip>

            <para>Once you make the alterations in the <xref
            linkend="build-changes"/> section, you should then remove
            <filename>slice-n-dice.desktop</filename>, leaving only the
            <filename>slice-n-dice.desktop.in</filename> file. The build
            process will merge any translations into this template file and
            build a desktop file containing strings for all the available
            locales. </para>

         </sect3>

         <sect3>
            <title>Server files</title>

            <para>Applications that are called by the &bas; to activate
            components on demand have a file with an extension of
            <filename>.server</filename> that describes how they are activated
            and contains some descriptive strings. So you need to mark up these
            files for translation as well. </para>

            <para>Similarly to the process for desktop files, rename
            <filename>GNOME_slice.server</filename> to
            <filename>GNOME_slice.server.in</filename>. Then open this file and
            edit any <literal>&lt;oaf_attribute&gt;</literal> tags that have a
            <literal>type="string"</literal> attribute. These tags will have a
            <literal>value="..."</literal> attribute and you should change this
            to be <literal>_value="..."</literal>. So, after markup, you will
            have some lines that look similar to
<programlisting><![CDATA[
<oaf_attribute name="name" type="string" _value="Slicing factory"/>
<oaf_attribute name="description" type="string"
               _value="Factory for slicing and dicing"/>
]]></programlisting>
            and so on. </para>

            <para>In some (indeed, most) projects, your server file will
            already be a template, since it will contain some variables that
            are subsituted by the <filename>configure</filename> script &mdash;
            things such as where the component is ultimately going to be
            installed. So the file will already be called
            <filename>GNOME_slice.server.in</filename>. In this case, you just
            add another level of <filename>.in</filename> extensions and create
            a <filename>GNOME_slice.server.in.in</filename> file. Note that the
            &intltool; application is run <emphasis>before</emphasis>
            <literal>configure</literal> does its substitutions. So, in the
            section about <xref linkend="build-changes"/> you need to just
            remember that &intltool; will be converting
            <filename>GNOME_slice.server.in.in</filename> to
            <filename>GNOME_slice.server.in</filename>. </para>

         </sect3>

         <sect3>
            <title>&glade; files</title>

            <para>If you are using &glade; to construct your user interface,
            then no special markup is required to have the strings in a glade
            file be recognised as translatable. The &intltool; application,
            which we will set up in the next section, knows which parts of a
            glade-format file are translatable (widget labels, messages,
            accessibility strings, and so forth) and will automatically extract
            them. </para>

            <para>The only thing you need to do when using &glade; is to not
            bother turning on the <literal>Save translatable strings</literal>
            option under the <literal>LibGlade</literal> tab in the
            <literal>Options</literal> box. The files containing marked up
            strings will instead be generated automatically by &glade;. </para>

         </sect3>

         <sect3>
            <title>XML files</title>

            <para>If your application comes with arbitrary format XML files,
            then you can mark up portions of those files for translation as
            well. Rename the file as previously, so
            <filename>slice.xml</filename>, say, becomes
            <filename>slice.xml.in</filename>. Then you can go through the file
            and mark any elements whose content should be translated with an
            initial underscore. So, for example,
<programlisting><![CDATA[
<type level="safe">
   <shape>blunt triangle</shape>
   <description>Creates a triangle without sharp corners.</description>
</type>
]]></programlisting>
            might be marked up as
<programlisting><![CDATA[
<type level="safe">
   <shape>blunt triangle</shape>
   <_description>Creates a triangle without sharp corners.</_description>
</type>
]]></programlisting>
            Notice how the <literal>&lt;description&gt;</literal> tag has been
            marked for translation. Note also that the closing tag has been
            similarly changed, so that the file is still well-formed XML
            (although probably no longer conforming to the same DTD as it may
            have originally). </para>

            <note>
               <itemizedlist>
                  <listitem>
                     <para><emphasis>FIXME: What happens when an element is
                     marked for translation and it contains another element.
                     Should the inner element be marked?</emphasis> </para>
                  </listitem>
                  <listitem>
                     <para><emphasis>If
                     <application>doc-i18n-tool</application> is ever fixed up,
                     that should replace this section, since it's less
                     intrusive.</emphasis> </para>
                  </listitem>
               </itemizedlist>
            </note>

         </sect3>

         <sect3>
            <title>&gconf; schema files</title>

            <para>The schema files used by &gconf; may contain short and long
            descriptions of any key; obviously these strings are candidates for
            translation. A key in a schema file may also have a default value
            which is translatable in the sense that it should be localised to
            be more appropriate. For example, a financial application may use
            <literal>"New York"</literal> as the default for the <literal>Stock
            Exchange"</literal> key in the <literal>C</literal> locale.
            However, <literal>"Frankfurt"</literal> may be a better default
            for this key in the <literal>de</literal> (German) locale. </para>

            <para>The way to have the appropriate keys pulled out of schema
            files is to wrap them in <literal>&lt;locale&gt;</literal> elements
            and specify the locale of the original file as
            <literal>C</literal>. So, you would mark the financial example
            above like in this example (some lines removed for brevity). </para>

            <example>
               <title><filename>financial.schemas</filename></title>
<programlisting><![CDATA[
<schema>
   <key>/schemas/apps/finance/preferences/current_market</key>
   ...
   <locale name="C">
      <default>New York</default>
      <short>Current stock exchange</short>
      <long>This key holds the name of the stock exchange that
      we are currently querying. It can have any string value 
      that corresponds to a world market.</long>
   </locale>
</schema>
]]></programlisting>
            </example>

            <para>Keys which do not have their descriptions and/or default
            values put inside a <literal>&lt;locale name="C"&gt;</literal>
            element will not be translated. You will usually always want to
            translate short and long descriptions, but only occasionally want
            to translate the default values. </para>

         </sect3>

         <sect3>
            <title>User and API documentation</title>

            <para>Unfortunately, at the present time, there is no easy way to
            convert user documentation or API documentation (such as that
            generated by <application>gtk-doc</application>) into a format that
            is consistent for translators. User documentation essentially has
            to be translated by manually going through the source document. API
            documentation currently does not support internationalisation.
            </para>

         </sect3>

      </sect2>
   
   </sect1>

   <sect1 id="build-changes" xreflabel="build changes">
      <title>Incorporating i18n into the package's build infrastructure</title>

      <para>So, after all the work in the previous section, you should now be
      at a point where you can alter your build system to incorporate all of
      the internationalisation changes. The changes to the build system provide
      functionality that falls into three loose categories.
         <itemizedlist>
            <listitem>
               <para>Detecting that the required tools exist at configuration
               and build time; </para>
            </listitem>
            <listitem>
               <para>Extracting the strings to be translated so that
               translators can do their work with a minimum of fuss; </para>
            </listitem>
            <listitem>
               <para>Merging the translations into the built product, ready for
               installation. </para>
            </listitem>
         </itemizedlist>
      </para>

      <para>I will assume that your package utilises the standard build method
      of running an &autogen.sh; script to run
      <application>aclocal</application>,
      <application>autoheader</application>,
      <application>autoconf</application> and
      <application>automake</application>. All of the changes you need to make
      in this section and the following ones are to your &configure.in; file(s)
      and to some of your &Makefile.am; files. </para>

      <para>The i18n support in GNOME relies heavily on the &intltool; tool,
      written by Darin Adler, Maciej Stachowiak and Kenneth Christiansen. It
      essentially extends the functionality of GNU &gettext; to include things
      like desktop files, &glade; and &gconf; support files, XML files, and a
      few other types that are not in common usage any longer. You only need
      &intltool; when you are building a package from the &autogen.sh; level.
      Distributed tarballs contain a copy of the relevant scripts and so do
      not require &intltool; on the users' machines. </para>

      <note>
         <para>If you are writing a very low-level library that does not
         require the extra functionality of &intltool;, it may be possible to
         just use &gettext; in your application. However, at present, this
         tutorial does not cover this option, since &intltool; adds very
         little overhead and is easy to use. </para>
      </note>

      <sect2 id="autogen-changes">
         <title>Changes to &autogen.sh;</title>

         <para>Firstly, ensure that your &autogen.sh; script will be able to
         bootstrap the whole process by locating the
         <filename>glib-gettextize</filename> script and then running it. If
         you leverage the &autogen.sh; script from the
         <application>gnome-common</application> module in GNOME's CVS
         repository, this is all done automatically for you and you can skip
         forwards to the next section. </para>

         <para>If you are not using the standard GNOME &autogen.sh; script, you
         will need to add a check for the appropriate scripts and then run
         whatever you found.  Here is some sample code that does this (checking
         for both a form of <application>gettextize</application> and for
         &intltool;.  </para>

         <example>
            <title>Additions to &autogen.sh;</title>
<programlisting><![CDATA[
if grep "^AM_[A-Z0-9_]\{1,\}_GETTEXT" "$CONFIGURE" >/dev/null; then
 if grep "sed.*POTFILES" "$CONFIGURE" >/dev/null; then
  GETTEXTIZE=""
 else
  if grep "^AM_GLIB_GNU_GETTEXT" "$CONFIGURE" >/dev/null; then
    GETTEXTIZE="glib-gettextize"
  else
    GETTEXTIZE="gettextize"
  fi

  $GETTEXTIZE --version < /dev/null > /dev/null 2>&1
  if test $? -ne 0; then
    echo
    echo "**Error**: You must have \`$GETTEXTIZE' installed" \
         "to compile $PKG_NAME."
    DIE=1
  fi
 fi
fi
(grep "^AC_PROG_INTLTOOL" "$CONFIGURE" >/dev/null) && {
(intltoolize --version) < /dev/null > /dev/null 2>&1 || {
 echo
 echo "**Error**: You must have \`intltoolize' installed" \
      "to compile $PKG_NAME."
 DIE=1
 }
}
]]></programlisting>
         </example>

         <para>Later on in &autogen.sh;, before running
         <filename>libtoolize</filename> or any of those scripts, you should
         bootstrap the i18n process by running
         <filename>glib-gettextize</filename> and
         <filename>intltoolize</filename> like this: </para>

         <example>
            <title>Further additions to &autogen.sh;</title>
<programlisting><![CDATA[
if test "$GETTEXTIZE"; then
 echo "Creating $dr/aclocal.m4 ..."
 test -r aclocal.m4 || touch aclocal.m4
 echo "Running $GETTEXTIZE...  Ignore non-fatal messages."
 echo "no" | $GETTEXTIZE --force --copy
 echo "Making aclocal.m4 writable ..."
 test -r aclocal.m4 && chmod u+w aclocal.m4
fi
if grep "^AC_PROG_INTLTOOL" $bn >/dev/null; then
 echo "Running intltoolize..."
 intltoolize --copy --force --automake
fi
]]></programlisting>
         </example>

         <para>A certain amount of customisation might be needed here if, for
         example, <filename>aclocal.m4</filename> was not in the current
         directory. For best results, copy an example from an existing
         application, such as &gconf;. </para>

         <note>
            <para>The reason for using <filename>glib-gettextize</filename>
            instead of the more natural <filename>gettextize</filename> is due
            to a difference in philosophy between the GNU maintainers of
            &gettext; and GNOME developers. The &gettext; maintainers argue
            that a script like <filename>gettextize</filename> should only be
            run when migrating between versions of &gettext; or when initially
            preparing a project for using &gettext;. In GNOME, however, we
            prefer not to store the files generated by
            <filename>glib-gettextize</filename> (which are essentially the
            same as those generated by <filename>gettextize</filename>) in CVS
            and just to generate them at autogen time. The two ways of working
            cannot be met by a single script, so the GNOME project uses a
            slightly changed version of the original &gettext; script. </para>
         </note>

      </sect2>

      <sect2 id="configure-changes">
         <title>Changes to &configure.in;</title>

         <para>There are a number of changes required to &configure.in;. You
         need to test for the existence of &intltool;, set up a few definitions
         for use at build time and list the languages for which you have
         translations. The code to do all of this is given in the next example.
         I have listed it all in one block, although traditionally, the
         &intltool; detection comes early in the &configure.in; and the rest of
         the tests go together at some point later in the file. </para>

         <example>
            <title>Text to be added to &configure.in;</title>
<programlisting><![CDATA[
AC_PROG_INTLTOOL([0.23])

GETTEXT_PACKAGE=slice-n-dice
AC_SUBST(GETTEXT_PACKAGE)
AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, "$GETTEXT_PACKAGE")

ALL_LINGUAS=
# AM_GLIB_GNU_GETTEXT

slicelocaledir='${prefix}/${DATADIRNAME}/locale'
AC_SUBST(slicelocaledir)
]]></programlisting>
         </example>

         <para>A couple of items need explanatson here. Firstly, the three
         lines dealing with <literal>GETTEXT_PACKAGE</literal> are used to
         define the message domain for this application and make it available
         both to the makefiles that are generated and also as a
         <literal>#define</literal> to the source code (this is done in the
         <literal>AC_DEFINE_UNQUOTED()</literal> macro). Recall from earlier,
         that the i18n support was initialised by a call to
         <literal>bindtextdomain()</literal> using
         <literal>GETTEXT_PACKAGE</literal> as the name. </para>

         <para>Secondly, I have commented out the
         <literal>AM_GLIB_GNU_GETTEXT</literal> macro because there are
         currently no translations available. Things tend to go wrong when
         <literal>ALL_LINGUAS</literal> is empty, so for now, we do not
         initialise the translations. One you have some translations available,
         you would add their language codes to <literal>ALL_LINGUAS</literal>
         and uncomment the <literal>AM_GLIB_GNU_GETTEXT</literal> macro. That
         would, in turn, cause <literal>ENABLE_NLS</literal> to be defined,
         which enables the i18n code, due to the way our header file was set up
         earlier (in the <xref linkend="i18n-header"/> section). The
         <literal>ALL_LINGUAS</literal> variable is a string of space separated
         language codes, so after adding a few languages, it might look like
         this <programlisting> ALL_LINGUAS="de en_AU no sv" </programlisting>
         </para>

         <para>Thirdly, the <literal>AC_PROG_INTLTOOL</literal> macro takes an
         optional argument specifying the minimal version required. I have
         specified verison 0.23 in this code fragment, since that is the first
         version that extracts the default key values in &gconf; schemas
         correctly. If you do not need this particular feature, it is safe to
         specify version 0.21, since that is widely available and works mostly
         correctly. </para>

         <para>Finally, I define a variable called
         <literal>slicelocaledir</literal> (you may change this name to
         anything you like) which specifies where the locale files will be
         installed. In the &Makefile.am; changes I will get to in the next
         section, this variable will be passed into each file as it is built
         and will be used in the <literal>bindtextdomain()</literal> call to
         initialise the i18n support. You may think that this should be done
         automatically, but this construction is required in order to make
         things build seamlessly on Solaris installations, where message files
         are stored in a slightly different location to that assumed by GNU's
         &gettext;. </para>

         <para>The last change required in &configure.in; is to go to the end
         of the file and add the file <filename>po/Makefile.in</filename> to
         the list of files generated by the <literal>AC_OUPUT</literal> macro.
         </para>

         <para>At this point your application should still build without
         problems. However, the i18n support will still be disabled (since no
         languages are present and <literal>AM_GLIB_GNU_GETTEXT</literal> is
         not called). Furthermore, even if languages were available, they would
         not be applied to a lot of the files that &intltool; manages, since we
         have not made the necessary build changes in the makefiles. That is
         the next step. </para>

      </sect2>

      <sect2 id="makefile-changes">
         <title>Makefile changes</title>

         <para>Firstly, edit the top-level &Makefile.am; and add
         <literal>po</literal> to the list of subdirectories to be descended
         into. So you would have a line that looks something like
<programlisting>
SUBDIRS = src po
</programlisting>
         </para>

         <para>Also, add <filename>intltool-extract.in</filename>,
         <filename>intltool-merge.in</filename> and
         <filename>intltool-update.in</filename> to the
         <literal>EXTRA_DIST</literal> rule in the top-level &Makefile.am;. Add
         these three filename, plus the same names without the
         <literal>.in</literal> extension to your
         <filename>.cvsignore</filename> in that directory.
         </para>

         <para>Then change to the directory containing the file with your
         <literal>main()</literal> function or library initialisation code.
         You need to edit the include flags in the &Makefile.am; for that
         directory and add a line to set up the directory for storing the
         message files.
<programlisting>
INCLUDES =                      \
    -I$(top_srcdir)             \
    ...
    -DSLICELOCALEDIR=\""$(slicelocaledir)"\"
</programlisting>
         Here, <literal>SLICELOCALEDIR</literal> matches the variable name you
         passed to the <literal>bindtextdomain()</literal> call (see <xref
         linkend="initialising-i18n-support"/>) and
         <literal>slicelocaledir</literal> matches the variable name you chose
         when editing &configure.in; in the previous section. </para>

         <para>The final piece of makefile editing required is to allow
         intltool to build fully translated versions of your desktop, schema,
         server and XML files. Back in the section about <xref
         linkend="marking-strings"/>, you created a number of new files with
         <literal>.in</literal> extensions and special markup to indicate
         fields that are to be translated. Every one of those files (without
         the <literal>.in</literal> extension) currently appears in some
         &Makefile.am;. It will appear in a line like
<programlisting>
desktop_DATA = slice-n-dice.desktop
</programlisting>
         You need to edit this to generate this file from the template file
         with the help of &intltool;. For the above example, we would change
         the &Makefile.am; to read
<programlisting>
desktop_in_files = slice-n-dice.desktop.in
desktop_DATA = $(slice_in_files:.desktop.in=.desktop)
@INTLTOOL_DESKTOP_RULE@
</programlisting>
         </para>

         <para>There are two changes involved here. Firstly, we now list all
         the desktop files (only one in this case, but you may have more) under
         a different name (one that is <emphasis>not</emphasis> special to
         &automake;). Then the <literal>desktop_DATA</literal> rule works out
         what files it contains by applying a transformation pattern to the
         files in the earlier list. </para>

         <para>The second change is the inclusion of some special makefile
         rules which take care of merging any available translations into
         <filename>slice-n-dice.desktop.in</filename> to create
         <filename>slice-n-dice.desktop</filename>. These rules are included
         using the <literal>@INTLTOOL_DESKTOP_RULE@</literal> variable, which is
         substituted as part of the <literal>AC_PROG_INTLTOOL</literal> macro
         in &configure.in;. </para>

         <para>Everything is similar for server, schema and generic XML files,
         except that <literal>@INTLTOOL_DESKTOP_RULE@</literal> is replaced
         with <literal>@INTLTOOL_SERVER_RULE@</literal>,
         <literal>@INTLTOOL_SCHEMAS_RULE@</literal> and
         <literal>@INTLTOOL_XML_RULE@</literal> respectively. You will also
         need to change the target that holds the filenames as well (the one
         called <literal>desktop_DATA</literal> above). You may have different
         targets for your desktop, schema, server and XML files. There are some
         more examples of how to make these changes in the
         <filename>README</filename> file that comes with the &intltool;
         distribution. </para>

         <para>Once you have made all these &Makefile.am; changes, you can
         remove the original desktop, etc, files (the ones without the
         <literal>.in</literal> extensions), since they are now
         generated automatically. You will also probably want to add the
         generated names to your <filename>.cvsignore</filename> files in the
         respective directories so that &cvs; does not complain about these
         newly created, unknown files. </para>

      </sect2>

      <sect2 id="po-changes">
         <title>Changes in the <filename>po/</filename> directory</title>

         <para>In order to help the build process extract all translatable
         strings, there are two important files that you need to put in the
         <filename>po</filename> subdirectory of your project &mdash;
         <filename>POTFILES.in</filename> and (possibly)
         <filename>POTFILES.skip</filename>. </para>

         <para>The <filename>POTFILES.in</filename> file contains a list of all
         the files in your project which contain translatable strings. This
         includes source code files, server files, desktop files, and so on.
         You can generate this file initially by running the command
         <userinput>intltool-update -m</userinput>. This will scan through all
         the possible source files and throw up a large error message listing
         all of the files it found with translatable strings in them. </para>

         <para>For each file in this error message, you need to determine if it
         really does contain translatable strings (which will almost always be
         the case) and add it to <filename>POTFILES.in</filename> if so. For
         files that do not contain translatable strings, but which
         <literal>intltool-update</literal> identifies, put the filename into
         <filename>POTFILES.skip</filename>. Once you have dealt with every
         file, you should be able to run <userinput>intltool-update
         -m</userinput> a second time and see a message like
         <computeroutput>All files containing translations are present in
         POTFILES.in.</computeroutput> </para>

         <para>Periodically running this command as you maintain your
         application is recommended, simply to verify that you have not
         accidently omitted any important files from
         <filename>POTFILES.in</filename>. </para>

         <para>During the build process, the <filename>po</filename> directory
         will contain a large number of generated files. Assuming your project
         is managed through a &cvs; repository, this will cause a large amount
         of noise to be emitted from any &cvs; command, since it will not know
         about these new files. Creating a <filename>.cvsignore</filename> file
         in the <filename>po</filename> directory with the following content
         should be enough to keep &cvs; quiet. </para>
<programlisting>
*.gmo
*.mo
*.pot
Makefile
Makefile.in
Makefile.in.in
POTFILES
cat-id-tbl.c
messages
missing
po2tbl.sed
po2tbl.sed.in
stamp-cat-id
</programlisting>

      </sect2>

<!--
   The build process...
      - 'LANG=C msgfmt -Ccv /dev/null <lang>.po' can be used to check a po file
        for errors.
-->
   </sect1>

   <sect1 id="what-next">
      <title>What happens next?</title>

      <para>Once you have reached this point, your work is essentially done!
      The translators can now go to work, converting all of your marked strings
      into their own language and putting the results back into the
      application. </para>

      <para>You may wish to run <userinput>intltool-update -r</userinput> from
      time to time to get a report on how much of the application is translated
      in each language. There is really little you can do about the results of
      this report, however, so it is purely for informational purposes. </para>

      <para>Typically, the interaction between developer and the translators
      will proceed something like the following. </para>

      <itemizedlist>
         <listitem>
            <para>A translator will create a new file for their language.  This
            will be called <filename>XX.po</filename>, where
            <literal>XX</literal> is replaced by the locale name (there is a
            recognised list of language and country codes used in these names).
            </para>
         </listitem>
         <listitem>
            <para>After translating some or all of the messages in the new
            file, the translator will commit the file in the
            <filename>po</filename> directory and update the
            <filename>ChangeLog</filename> in that directory. They will also
            add the new language code to the <literal>ALL_LINGUAS</literal>
            variable in &configure.in;. </para>
         </listitem>
         <listitem>
            <para>Before making a release, you (the developer) should give all
            the translators a bit of notice so that they can update and commit
            their translations. Typically, a week is not an unreasonable amount
            of time. </para>
         </listitem>
         <listitem>
            <para>Right before tagging the CVS tree for the release, you should
            commit any language (<literal>.po</literal>) files that your build
            process changes. You should  do this <emphasis>only</emphasis>
            when you are releasing in order to avoid creating unnecessary
            conflicts for the translators. In general, you should leave the
            language files alone, but a release is the time when you
            synchronise what is in the CVS tree with what is in the code.
            </para>
         </listitem>
      </itemizedlist>

      <para>Aside from the release process, the only other responsibility you,
      as a developer, has with respect to internationalisation, is to ensure
      that any new strings you add are marked for translation. From time to
      time, it is worth running your application in one of the fully translated
      languages (if you have any), just to see if any English words appear as
      you move through the various states. </para>

   </sect1>

   <sect1 id="tips" xreflabel="tips and tricks">
      <title>Tips and Tricks</title>

      <para>There are a number of little tricks about the i18n process that
      have accumulated on various mailing lists and other places. I will list
      the more significant ones here (and add any extras that people send to me
      &mdash; see the <xref linkend="feedback"/> section). </para>

      <itemizedlist>
         <listitem>
            <para>Do not ever mark an empty string for translation. This has
            the effect of retrieving the header section from the respective
            language file, rather than returning an empty string. </para>

            <para>While it is relatively simple to avoid writing code such as
            <literal>_("")</literal>, you may need to be careful if the string
            is dynamically created. If there is any possibility that it might
            be empty, check first and do <emphasis>not</emphasis> call
            <literal>_()</literal> if there is no content to translate. </para>
         </listitem>
         <listitem>
            <para>If you are trying to test an internationalised application,
            you will need to remember to run <userinput>make
            install</userinput> to see the results of any translations. Because
            the i18n support in the library is initialised with the explicit
            path to where the message files are stored (the second parameter to
            <literal>bindtextdomain()</literal>), that is where the program
            will look. There is no fallback in place to look in the current
            directory if something is not found in the specificed locale
            directory. </para>
         </listitem>
         <listitem>
            <para>When creating the <emphasis>About</emphasis> box for your
            application, one of the fields you can pass in is the translator's
            name. In order to display the translator for the current locale,
            most GNOME applications have code similar to the following:
<programlisting>
gchar *translator_credits = _("translator_credits");
...
about_box = gnome_about_new(...
             strcmp (translator_credits, "translator_credits") != 0 ? \
             translator_credits : NULL, 
                            ...
</programlisting>
            Translators then translate the
            <literal>translator_credits</literal> string to their own name. If
            nobody translated the current locale (and so the
            <literal>_()</literal> call returned the original string), then no
            translator credits are passed into the about box's constructor and
            that tab is not available. </para>

            <para>It is recommended that you use the string
            <literal>translator_credits</literal> for this purpose, since
            translators are becoming used to seeing that string and knowing how
            to translate it in the correct context. </para>
         </listitem>
      </itemizedlist>

   </sect1>

   <appendix id="checklist">
      <title>Checklist for internationalising an application</title>

      <para><emphasis>[TODO: Distill the previous sections into a simple list
      for developers who mostly know what they are doing, but wish to check
      that nothing has been missed.]</emphasis></para>

   </appendix>

   <bibliography id="bibliography">
      <bibliodiv>
         <title>Online resources</title>

         <biblioentry id="bib-kmaraas">
            <abbrev>kmaraas</abbrev>
            <title>Translation of the GNOME desktop environment</title>
            <subtitle>(<ulink
            url="http://developer.gnome.org/projects/gtp/translate-gnome/index.html"/>)</subtitle>
         </biblioentry>

         <biblioentry id="bib-gettext">
            <abbrev>gettext</abbrev>
            <title>Gettext manual</title>
            <subtitle>(<ulink
            url="http://www.gnu.org/manual/gettext/html_chapter/gettext_toc.html"/>)</subtitle>
         </biblioentry>

      </bibliodiv>

   </bibliography>

</article>

