<?xml version="1.0" encoding="UTF-8"?>


<chapter id="feedback">
    <title>Feedback</title>

    <sect1 id="responsiveness">
      <title>Characteristics of Responsive Applications</title>

      <para>Although highly responsive applications can differ widely from one another, they share the following characteristics:</para>
      <itemizedlist>
	<listitem><para>They keep up with users, even when they cannot fulfill users' requests immediately.</para></listitem>

	<listitem><para>They handle queued requests as users would expect, discarding requests that are no longer relevant and reordering requests according to users' probable priorities.</para></listitem>

	<listitem><para>They let users do other work while long operations proceed to completion&mdash; especially operations not requested by users&mdash; such as reclaiming unused memory or other &quot;housekeeping&quot; operations.</para></listitem>

	<listitem><para>They provide enough feedback for users to understand what they are doing, and organize feedback according to users' abilities to comprehend and react to it.</para></listitem>

	<listitem><para>They let users know when processing is in progress.</para></listitem>
	
	<listitem><para>They let users know or estimate how long lengthy operations will take.</para></listitem>

	<listitem><para>They let users set the pace of work, when possible, and they let users stop requested tasks that have started but not finished.</para></listitem>
      </itemizedlist>

      <para>Highly responsive applications put users in control by quickly acknowledging each user request, by providing continuous feedback about progress toward fulfilling each request, and by letting users complete tasks without unacceptable delays.</para>

      <para>Even applications with attractive, intuitive user interfaces can lack responsiveness. Typically, unresponsive applications have at least one of the following problems:</para>

      <itemizedlist>

	<listitem><para>They provide late feedback&mdash; or no feedback&mdash; for users' requests, leaving users wondering what the application has done or is doing.</para></listitem>

	<listitem><para>When performing extended operations, they prevent users from doing other work or cancelling the extended operation.</para></listitem>

	<listitem><para>They fail to display estimates of how long extended operations will last, forcing users to wait for unpredictable periods.</para></listitem>

	<listitem><para>They ignore users' requests while doing unrequested &quot;housekeeping&quot;, forcing users to wait at unpredictable times&mdash; often without feedback.</para></listitem>

      </itemizedlist>
      
      <para>You can sometimes possible to improve an application's responsiveness without speeding up the application's code. For tips on how to make such improvements, see <link linkend="responding-to-user-requests">Responding to User Requests</link>.</para>
      
    </sect1>

    <sect1 id="acceptable-response-times">

      <title>Acceptable Response Times</title>
      
      <para>Some user interface events require shorter response delays than others. For example, an application's response to a user's mouse click or key press needs to be much faster than its response to a request to save a file. The table below shows the maximum acceptable response delay for typical interface events.</para>

      <table frame='all'>
	<title>Maximum acceptable response times for typical events</title>
	<tgroup cols='2' align='left'>
	  <thead>
	    <row>
	      <entry>UI Event</entry>
	      <entry>Maximum Acceptable Response Time</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Mouse click, pointer movement, window movement or resizing, keypress, button press, drawing gesture, other UI input event involving hand-eye co-ordination</entry>
	      <entry>0.1 second</entry>
	    </row>
	    <row>
	      <entry>Displaying progress indicators, completing ordinary user commands (e.g. closing a window), completing background tasks (e.g. reformatting a table)</entry>
	      <entry>1.0 second</entry>
	    </row>
	    <row>
	      <entry>Displaying a graph or anything else a typical user would expect to take time (e.g. displaying a new list of all a company's financial transactions for an accounting period)</entry>
	      <entry>10.0 seconds</entry>
	    </row>
	    <row>
	      <entry>Accepting and processing all user input to any task</entry>
	      <entry>10.0 seconds</entry>
	    </row>
	    
	  </tbody>
	</tgroup>
      </table>

      <para>Make each response delay in your application as short as possible, unless users need time to see the displayed information before it is erased. The acceptable response delay for each event is based on a typical user's sense that the event is a logical point at which to stop or pause. The greater that sense is, the more willingly the user will wait for a response. Verify that your application responds to users' requests within the limits listed in the table above. If your application cannot respond within those limits, it probably has one or more general problems caused by a particular algorithm or module.</para>

      <para>Recommendations:</para>
      
      <itemizedlist>

	<listitem><para>Verify that your application provides feedback within 100 milliseconds (0.1 second) after each key press, movement of the mouse, or other physical input from the user.</para></listitem>

	<listitem><para>Verify that your application provides feedback within 100 milliseconds (0.1 second) after each change in the state of controls that react to input from the user&mdash; for example, displaying menus or indicating drop targets.</para></listitem>

	<listitem><para>Verify that your application takes no longer than 1 second to display each progress indicator, complete each ordinary user command, or complete each background task.</para></listitem>

	<listitem><para>Verify that your application takes no longer than 10 seconds to accept and process all user input to any task&mdash;including user input to each step of a multistep task, such as a wizard.</para></listitem>

      </itemizedlist>

    </sect1>
    
    <sect1 id="responding-to-user-requests">
      
      <title>Responding to User Requests</title>

      <para>If your application takes too long to respond, users will become frustrated. Use these techniques to improve the responsiveness of your application.</para>

      <para>Recommendations:</para>

      <itemizedlist>
	<listitem><para>Display feedback as soon as possible.</para></listitem>

	<listitem><para>If you cannot display all the information that a user has requested, display the most important information first.</para></listitem>

	<listitem><para>Save time by displaying approximate results while calculating finished results.</para></listitem>

	<listitem><para>If users are likely to repeat a time-consuming command in rapid succession, save time by faking the command's effects instead of repeatedly processing the command. For example, if a user adds several rows to a table stored in a database, you might display each new row immediately but delay actually creating each new row in the database until the user finished adding all the rows.</para></listitem>
	
	<listitem><para>Work ahead. Prepare to perform the command that is most likely to follow the current command. That is, use idle time to anticipate users' probable next requests. For example, as the user of an email application reads the currently displayed new message, the application might prepare to display the next new message.</para></listitem>

	<listitem><para>Use background processing. Perform less important tasks &mdash;such as housekeeping&mdash; in the background, enabling users to continue working.</para></listitem>

	<listitem><para>Delay work that is not urgent. Perform it later, when more time is available.</para></listitem>

	<listitem><para>Discard unnecessary operations. For example, to move back several pages in a web browser, a user might click the browser's <guibutton>Back</guibutton> button several times in rapid succession. To display the final requested page more quickly, the browser might not display the pages visited between the current page and that final page.</para></listitem>

	<listitem><para>Use dynamic time management. At run time, change how your application prioritizes user input and other processing, based on the application's current state. For example, if a user is typing text in one word-processing document while printing another, the word-processing application might delay the printing task if the user shifts to an editing task (such as cutting and pasting text) that requires greater resources.</para></listitem>

	<listitem><para>In your application, display an estimate of how long each lengthy operation will take.</para>
	  <itemizedlist>

	    <listitem><para>If a command might take longer than 5 seconds to complete its work on an object, allow users to interact with any parts of the object and parts of the application that are not directly affected by the command.</para></listitem>

	    <listitem><para>If a command provides lengthy output, show partial results as they become available. Scroll the results (if necessary) until the user moves input focus to a component (e.g. a scrollbar or text area) involved in the scrolling.</para></listitem>

	  </itemizedlist>
	  
	</listitem>
	
      </itemizedlist>
      
    </sect1>

    <sect1 id="feedback-types">
      <title>Types of Visual Feedback</title>

      <para>You can use two types of visual feedback for operations in your application&mdash; pointer feedback and progress animations.</para>

      <sect2 id="pointer-feedback">
	<title>Pointer Feedback</title>
	
	<para>Pointer feedback changes the shape of the pointer.  For example, a wait pointer indicates that an operation is in progress and that the user cannot do other tasks.</para>

	<para>(picture of wait pointer required)</para>

      </sect2>
      
      
      <sect2 id="progress-animations">
	<title>Progress Animations</title>
	
	<para>Progress animations show either how much of an operation is complete, or only that an operation is ongoing.  Normally, these take the form of either a progress bar or a progress checklist.</para>
	
	<para>Recommendations:</para>
	
	<itemizedlist>
	  <listitem><para>When displaying a progress animation, open it as quickly as possible and close it automatically as soon as the associated operation is complete.</para></listitem>
	  <listitem><para>Use a measured-progress bar if your application can estimate either:</para>
	    <itemizedlist>
	      <listitem><para>How long the operation will take</para></listitem>
	      <listitem><para>What proportion of the operation is complete</para></listitem>
	    </itemizedlist>
	  </listitem>
	  
	  <listitem><para>If your application can make neither estimate, use an indeterminate-progress bar for operations with only one step. For operations with two or more steps, use a progress checklist that dynamically displays a check mark for each completed step.</para>

	    <para>(Picture of each required)</para>
	    
	  </listitem>
	  
	</itemizedlist>
	
	<sect3 id="progress-bars">	  
	  <title>Progress Bars</title>
	  
	  <para>You can use two main types of progress bars in your application&mdash; measured-progress bars and indeterminate-progress bars. There are three types of measured progress bars, but only one type of indeterminate progress bar, which are described in the following sections.</para>

	  <para>Ensure that a measured-progress bar measures an operation's total time or total work, not just that of a single step. An exception is a progress bar that measures the total time or work of the current step in a progress checklist.</para>

	  <sect4 id="time-remaining">
	    
	    <title>Time-remaining Progress Indicator</title>
	    
	    <para>An animation consisting of a bar whose changing length indicates how much time remains in an operation, and text stating how much time remains before the operation will be complete. Time-remaining bars are the most useful type of progress bar.</para>
	    
	    <figure><title>A simple 'time remaining' progress dialog</title>
	      <mediaobject>
		<imageobject>
		  <imagedata fileref="images/progress-time.png" format="PNG"/>
		</imageobject>
		<textobject><phrase>A simple time-remaining progress dialog</phrase>           </textobject>
	      </mediaobject>
	    </figure>

	    <para>Use a time-remaining bar if your application will display an initial estimate of an operation's remaining time and then periodically display updated estimates. Each updated estimate should be based on changes that have occurred and that will cause the operation to finish more quickly or more slowly. If the operation will finish more slowly, your application can display an updated estimate that is greater than the estimate previously displayed.</para>
	    
	  </sect4>
	   
	  <sect4 id="proportion-completed">
	    <title>Proportion-completed Progress Indicator</title>

	    <para>A bar whose changing length represents the completed proportion&mdash; typically a percentage&mdash; of an operation's total units of work.  Proportion-completed bars are less useful than time-remaining bars but more useful than typical-time bars.</para>
	    <figure>
	      <title>A simple 'proportion completed' progress dialog</title>
	      <mediaobject>
		<imageobject>
		  <imagedata fileref="images/progress-proportion.png" format="PNG"/>
		</imageobject>
		<textobject><phrase>A simple proportion-completed progress dialog</phrase>           
		</textobject>
	      </mediaobject>
	    </figure>

	    <para>Use a proportion-completed bar if your application will estimate an operation's duration by counting the units of work completed so far, without regard for changes that might affect how quickly the remaining units will be completed. If the operation will process a known number of objects or a set of objects whose total size is known, equate the length of the bar to the total number of units of work that the operation will perform. At least every four seconds, update the bar to show how much of the operation is complete.</para>

	  </sect4>

	  <sect4 id="typical-time">
	    <title>Typical-time Progress Indicator</title>
	    
	    <para>A bar whose changing length indicates how much time remains if an operation takes as long as it typically does. Typical-time bars are the least precise type of measured-progress bar, but they are more useful than indeterminate-progress bars.</para>
	    <figure>
	      <title>A simple 'typical time remaining' progress dialog</title>
	      
	      <mediaobject>
		<imageobject>
		  <imagedata fileref="images/progress-proportion.png" format="PNG"/>
		</imageobject>
		<textobject><phrase>A simple 'typical time remaining' progress dialog</phrase>           </textobject>
	      </mediaobject>
	    </figure>

	    <para>For some operations, you cannot estimate the time remaining or the proportion of work completed. However, if you can estimate the typical time for that operation, you can provide feedback with a typical-time bar.</para>
	    
	    <para>If your application overestimates the completed amount of work, the length of the bar can indicate &quot;almost complete&quot; until the operation is complete. If your application underestimates how much work is complete, the application can fill the remaining portion of the bar when the operation is complete.</para>

	  </sect4>
	  

	  <sect4 id="indeterminate-progress">
	    <title>Indeterminate-progress indicator</title>
	    
	    <para>An animated bar indicating only that an operation is ongoing. Indeterminate-progress bars are the least precise type of progress bar.</para>
	    
	    <figure>
	      <title>A simple 'indeterminate time' progress dialog</title>
	      <mediaobject>
		<imageobject>
		  <imagedata fileref="images/progress-indeterminate.png" format="PNG"/>
		</imageobject>
		<textobject><phrase>A simple indeterminate time progress dialog</phrase>           </textobject>
	      </mediaobject>
	    </figure>

	    <para>Use an indeterminate-progress bar to provide feedback only for operations whose duration you cannot estimate at all.</para>
	    
	  </sect4>
	  
	</sect3>
	
	<sect3 id="progress-checklists">
	  
	  <title>Progress Checklists</title>
	  
	  <para>A progress checklist shows the sequence of stages in an operation but does not display time estimates for those stages.</para>
	  <para>example required</para>

	  <para>When providing feedback with a progress checklist, you can include a measured-progress bar directly below the checklist. The bar measures the progress of the current step in the progress checklist.</para>
	  
	</sect3>
	
      </sect2>
      
    </sect1>

    <sect1 id="choosing-correct-feedback">
      <title>Choosing Appropriate Feedback</title>

      <para>To determine which type of visual feedback to provide for a particular operation, consider these factors:</para>

      <itemizedlist>

	<listitem><para>Whether your application can provide an estimate of the operation's progress.</para></listitem>
	<listitem><para>Whether the operation blocks the user from issuing further commands in your application.</para></listitem>
	<listitem><para>Whether your application has a dedicated space&mdash; such as a status bar&mdash; for indicating the status of operations.</para></listitem>
      </itemizedlist>

      <para>The table below shows which type of feedback your application should provide for operations that usually take at least 1 second to finish. In this table, &quot;Internal progress animations&quot; are progress animations displayed in an application's dedicated status area, and &quot;External progress animations&quot; are progress animations displayed somewhere other than in a dedicated status area&mdash; typically, in an alert box.</para>      

      <table frame='all'>
	<title>Visual feedback types for operations that take at least 1 second</title>
	<tgroup cols='4' align='left'>
	  <thead>
	    <row>
	      <entry>Duration usually &gt;5 seconds?</entry>
	      <entry>User blocked from issuing further commands?</entry>
	      <entry>Application has dedicated status area?</entry>
	      <entry>Appropriate feedback</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Yes</entry>
	      <entry>Yes</entry>
	      <entry>Yes</entry>
	      <entry>Internal progress animation and pointer feedback</entry>
	    </row>
	    <row>
	      <entry>Yes</entry>
	      <entry>Yes</entry>
	      <entry>No</entry>
	      <entry>Pointer feedback</entry>
	    </row>
	    <row>
	      <entry>Yes</entry>
	      <entry>No</entry>
	      <entry>Yes</entry>
	      <entry>Internal progress animation</entry>
	    </row>
	    <row>
	      <entry>No</entry>
	      <entry>Yes</entry>
	      <entry>Yes</entry>
	      <entry>Internal progress animation and pointer feedback</entry>
	    </row>
	    <row>
	      <entry>No</entry>
	      <entry>Yes</entry>
	      <entry>No</entry>
	      <entry>External progress animation and pointer feedback</entry>
	    </row>
	    <row>
	      <entry>No</entry>
	      <entry>No</entry>
	      <entry>Yes</entry>
	      <entry>Internal progress animation</entry>
	    </row>
	    <row>
	      <entry>No</entry>
	      <entry>No</entry>
	      <entry>No</entry>
	      <entry>External progress animation</entry>
	    </row>
	    
	  </tbody>
	</tgroup>
      </table>

      <para>In general, use a wait pointer in your user interface whenever users are blocked from interaction with your application for 1 second or longer. Display the wait pointer less than 1 second after the operation begins.  If a command will likely take 10 seconds or longer to finish, provide a <guibutton>Stop</guibutton> button that lets users terminate the command's processing even if your application cannot undo the command's effects&mdash; see <link linkend="interrupting-commands">Letting Users Interrupt Operations</link>.</para>
      
    </sect1>
    
    <sect1 id="interrupting-commands">
      <title>Letting Users Interrupt Operations</title>
      
      <para>Users sometimes need to stop a command&mdash; for example, because it is taking too long. Your application should let users stop commands in progress&mdash;even if stopping a command cannot undo, or &quot;roll back&quot;, all the command's effects.</para>
      
      <para>To let users stop a command, place a <guibutton>Stop</guibutton> button near the progress animation for that command.</para>
      
      <para>Alternatively, you can place the <guibutton>Stop</guibutton> button near the user-interface control with which the user issued the command that needs to be stopped. Place the <guibutton>Stop</guibutton> button in this alternative location only if:</para>
      
      <itemizedlist>
	
	<listitem><para>There is no progress animation for command, or</para></listitem>
	
	<listitem><para>The progress animation is in a window's status area or in another location that lacks space for a <guibutton>Stop</guibutton> button.</para></listitem>
	
      </itemizedlist>
      
      <para>If a user clicks the <guibutton>Stop</guibutton> button, the effect should depend on whether terminating a command can have unwanted side-effects, such as an incomplete rollback of changes.</para>
      
      <table frame='all'>
	<title>Correct behavior for a <guibutton>Stop</guibutton> button that terminates an operation</title>
	<tgroup cols='2' align='left'>
	  <thead>
	    <row>
	      <entry>Could terminating have unwanted side-effects?</entry>
	      <entry>Clicking <guibutton>Stop</guibutton>should...</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>No</entry>
	      <entry>Immediately terminate the command.</entry>
	    </row>
	    <row>
	      <entry>Yes</entry>
	      <entry>Open an alert box that warns of potential side effects. The alert box should have only two buttons: one for continuing the command's processing (cancelling the request to terminate it), and one for immediately terminating the command's processing (despite potential side effects).</entry>
	    </row>
	    
	  </tbody>
	</tgroup>
      </table>
      
      <para>If clicking the <guibutton>Stop</guibutton> button opens an alert box, ensure the button labels of the alert box are specific and precise. Ambiguous button labels can cause users to terminate or continue a command unintentionally.</para>
      
      <para>If stopping a partially completed command will not undo all the command's effects, display an alert box to warn users. Ensure that the alert box includes two buttons that enable users to choose between continuing the partially completed command or terminating the command regardless of the side effects. Label each button of the alert box as specifically as possible, for example: <guibutton>Continue Deleting Files</guibutton> and <guibutton>Stop Deleting Files</guibutton> (default).</para>

    </sect1>
    
  </chapter>
